##
## Exported symobls in package `Matrix`
##

## Exported package methods

`.__T__qr.Q:base` <- "<environment>"

.__C__indMatrix <- new("classRepresentation", slots = list(perm = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    sparseMatrix = new("SClassExtension", subClass = "indMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("indMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("indMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("indMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), compMatrix = new("SClassExtension", subClass = structure("indMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "indMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("indMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "generalMatrix"), "indMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "indMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "indMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "indMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "indMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "indMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "indMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        n <- object@Dim[1]
        d <- object@Dim[2]
        perm <- object@perm
        if (length(perm) != n) 
            return(paste("length of 'perm' slot must be", n))
        if (n > 0 && (any(perm > d) || any(perm < 1))) 
            return("'perm' slot is not a valid index")
        TRUE
    }, access = list(), className = structure("indMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(pMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "indMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            class(from) <- "indMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("perm", "Dim", "Dimnames", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


onenormest <- function (A, t = min(n, 5), A.x, At.x, n, silent = FALSE, quiet = silent, 
    iter.max = 10, eps = 4 * .Machine$double.eps) 
{
    mi.A <- missing(A)
    mi.A.x <- missing(A.x)
    mi.At.x <- missing(At.x)
    no.A.x <- mi.A.x || !is.function(A.x)
    no.At.x <- mi.At.x || !is.function(At.x)
    if (mi.A && (no.A.x || no.At.x)) 
        stop("must either specify 'A' or the functions 'A.x' and 'At.x'")
    if (!mi.A && (!mi.A.x || !mi.At.x)) 
        warning("when 'A' is specified, 'A.x' and 'At.x' are disregarded")
    if (mi.A) {
        stopifnot(is.numeric(n), length(n) == 1, n == round(n), 
            n >= 0)
    }
    else {
        if (length(d <- dim(A)) != 2 || (n <- d[1]) != d[2]) 
            stop("'A' must be a square matrix")
        rm(d)
    }
    stopifnot(is.numeric(t), length(t) == 1, t >= 1, iter.max >= 
        1)
    X <- matrix(runif(n * t), n, t)
    X <- X/rep(colSums(X), each = n)
    been_there <- logical(n)
    I.t <- diag(nrow = t)
    est_old <- 0
    S <- matrix(0, n, t)
    for (iter in 1:(iter.max + 1)) {
        Y <- if (mi.A) 
            A.x(X)
        else A %*% X
        imax <- which.max(cY <- colSums(abs(Y)))
        est <- cY[imax]
        if (est > est_old || iter == 2) 
            w <- Y[, imax]
        if (iter >= 2 && est < est_old) {
            est <- est_old
            break
        }
        est_old <- est
        S_old <- S
        if (iter > iter.max) {
            if (!silent) 
                warning(gettextf("not converged in %d iterations", 
                  iter.max), domain = NA)
            break
        }
        S <- sign(Y)
        partest <- apply(abs(crossprod(S_old, S) - n) < eps * 
            n, 2, any)
        if (all(partest)) {
            if (!quiet) 
                message("hit a cycle (1) -- stop iterations")
            break
        }
        if (any(partest)) {
            numpar <- sum(partest)
            replacements <- matrix(sample(c(-1, 1), n * numpar, 
                replace = TRUE), n, numpar)
            S[, partest] <- replacements
        }
        partest <- apply(crossprod(S) - I.t == n, 2, any)
        if (any(partest)) {
            numpar <- sum(partest)
            replacements <- matrix(sample(c(-1, 1), n * numpar, 
                replace = TRUE), n, numpar)
            S[, partest] <- replacements
        }
        Z <- if (mi.A) 
            At.x(S)
        else crossprod(A, S)
        h <- pmax.int(2, as(abs(Z), "matrix"))
        dim(h) <- dim(Z)
        mhi <- apply(h, 2, which.max)
        if (iter >= 2 && all(mhi == imax)) {
            if (!quiet) 
                message("hit a cycle (2) -- stop iterations")
            break
        }
        r <- apply(h, 2, sort.int, decreasing = TRUE, index.return = TRUE)
        h <- sapply(r, `[[`, "x")
        ind <- sapply(r, `[[`, "ix")
        if (t > 1) {
            firstind <- ind[1:t]
            if (all(been_there[firstind])) {
                break
            }
            ind <- ind[!been_there[ind]]
            if (length(ind) < t) {
                if (!quiet) 
                  message("not enough new vecs -- stop iterations")
                break
            }
        }
        X <- matrix(0, n, t)
        X[cbind(ind[1:t], 1:t)] <- 1
        been_there[ind[1:t]] <- TRUE
    }
    v <- integer(n)
    v[imax] <- 1L
    list(est = est, v = v, w = w, iter = iter)
}


.nC2l <- function (from) 
.Call(nz_pattern_to_Csparse, from, 1L)


.__C__sparseQR <- new("classRepresentation", slots = list(V = structure("dgCMatrix", package = "Matrix"), 
    beta = structure("numeric", package = "methods"), p = structure("integer", package = "methods"), 
    R = structure("dgCMatrix", package = "Matrix"), q = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods")), contains = list(
    MatrixFactorization = new("SClassExtension", subClass = "sparseQR", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("sparseQR"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(sparseQR_validate, object), access = list(), className = structure("sparseQR", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__diag:base` <- "<environment>"

isDiagonal <- new("standardGeneric", .Data = function (object) 
standardGeneric("isDiagonal"), generic = "isDiagonal", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "object", 
    default = NULL, skeleton = (function (object) 
    stop("invalid call in method dispatch to 'isDiagonal' (no default method)", 
        domain = NA))(object))


expm <- new("standardGeneric", .Data = function (x) 
standardGeneric("expm"), generic = "expm", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x) 
    stop("invalid call in method dispatch to 'expm' (no default method)", 
        domain = NA))(x))


cbind2 <- methods::cbind2 # re-exported from methods package

nnzero <- new("standardGeneric", .Data = function (x, na.counted = NA) 
standardGeneric("nnzero"), generic = "nnzero", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x, na.counted = NA) 
    stop("invalid call in method dispatch to 'nnzero' (no default method)", 
        domain = NA))(x, na.counted))


`.__T__[:base` <- "<environment>"

.__C__ldenseMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(lMatrix = new("SClassExtension", subClass = "ldenseMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), denseMatrix = new("SClassExtension", subClass = structure("ldenseMatrix", package = "Matrix"), 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "ldenseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "ldenseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), xMatrix = new("SClassExtension", subClass = "ldenseMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "lMatrix", dataPart = FALSE, distance = 2), 
        Mnumeric = new("SClassExtension", subClass = "ldenseMatrix", 
            superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "ldenseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3), replValueSp = new("SClassExtension", 
            subClass = "ldenseMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "ldenseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3)), virtual = TRUE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("ldenseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(lgeMatrix = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = "ldenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("lgeMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltrMatrix = new("SClassExtension", subClass = "ltrMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("ltrMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltpMatrix = new("SClassExtension", subClass = "ltpMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("ltpMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsyMatrix = new("SClassExtension", subClass = "lsyMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("lsyMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lspMatrix = new("SClassExtension", subClass = "lspMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("lspMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__atomicVector <- new("ClassUnionRepresentation", slots = list(), contains = list(), 
    virtual = TRUE, prototype = logical(0), validity = NULL, 
    access = list(), className = structure("atomicVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(logical = new("SClassExtension", 
        subClass = "logical", superClass = "atomicVector", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "atomicVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "atomicVector", dQuote("logical"), "atomicVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), integer = new("SClassExtension", subClass = "integer", 
        superClass = "atomicVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "atomicVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "atomicVector", dQuote("integer"), "atomicVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), numeric = new("SClassExtension", subClass = "numeric", 
        superClass = "atomicVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "atomicVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "atomicVector", dQuote("numeric"), "atomicVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), complex = new("SClassExtension", subClass = "complex", 
        superClass = "atomicVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "atomicVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "atomicVector", dQuote("complex"), "atomicVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), raw = new("SClassExtension", subClass = "raw", 
        superClass = "atomicVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "atomicVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "atomicVector", dQuote("raw"), "atomicVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), character = new("SClassExtension", subClass = "character", 
        superClass = "atomicVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "atomicVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "atomicVector", dQuote("character"), "atomicVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), factor = new("SClassExtension", subClass = "factor", 
        superClass = "atomicVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            if (strict) 
                from <- from@.Data
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "integer", TRUE)
            as(.value, "atomicVector") <- value
            value <- .value
            {
                from@.Data <- as(value, "integer", strict = FALSE)
                from
            }
        }, simple = TRUE, by = "integer", dataPart = FALSE, distance = 2), 
        double = new("SClassExtension", subClass = "double", 
            superClass = "atomicVector", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                from <- {
                  class(from) <- "numeric"
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  class(value) <- "double"
                  value
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 2), signature = new("SClassExtension", 
            subClass = "signature", superClass = "atomicVector", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "character", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
            }, simple = TRUE, by = "character", dataPart = FALSE, 
            distance = 2), className = new("SClassExtension", 
            subClass = "className", superClass = "atomicVector", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "character", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
            }, simple = TRUE, by = "character", dataPart = FALSE, 
            distance = 2), ObjectsWithPackage = new("SClassExtension", 
            subClass = "ObjectsWithPackage", superClass = "atomicVector", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "character", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
            }, simple = TRUE, by = "character", dataPart = FALSE, 
            distance = 2), ordered = new("SClassExtension", subClass = "ordered", 
            superClass = "atomicVector", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "integer", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  .value <- as(from, "factor", TRUE)
                  as(.value, "integer") <- value
                  value <- .value
                  {
                    S3Part(from) <- value
                    from
                  }
                }
            }, simple = TRUE, by = "integer", dataPart = FALSE, 
            distance = 3), factor = new("SClassExtension", subClass = "factor", 
            superClass = "atomicVector", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                from <- {
                  if (strict) 
                    from <- from@.Data
                  {
                    class(from) <- "numeric"
                    from
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  .value <- as(from, "integer", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "integer", strict = FALSE)
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 3), ordered = new("SClassExtension", subClass = "ordered", 
            superClass = "atomicVector", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "factor")
                    else from
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    {
                      class(from) <- "numeric"
                      from
                    }
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "atomicVector") <- value
                value <- .value
                {
                  .value <- as(from, "factor", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    S3Part(from) <- value
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 4)), versionKey = <pointer: (nil)>, sealed = FALSE)


expand <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("expand"), generic = "expand", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x, ...) 
    stop("invalid call in method dispatch to 'expand' (no default method)", 
        domain = NA))(x, ...))


fac2Sparse <- function (from, to = c("d", "i", "l", "n", "z"), drop.unused.levels = TRUE, 
    giveCsparse = TRUE, factorPatt12, contrasts.arg = NULL) 
{
    stopifnot(is.logical(factorPatt12), length(factorPatt12) == 
        2)
    if (any(factorPatt12)) 
        m <- fac2sparse(from, to = to, drop.unused.levels = drop.unused.levels, 
            giveCsparse = giveCsparse)
    ans <- list(NULL, if (factorPatt12[2]) m)
    if (factorPatt12[1]) {
        if (is.null(contrasts.arg)) 
            contrasts.arg <- getOption("contrasts")[if (is.ordered(from)) 
                "ordered"
            else "unordered"]
        ans[[1]] <- crossprod(if (is.character(contrasts.arg)) {
            stopifnot(is.function(FUN <- get(contrasts.arg)))
            FUN(rownames(m), sparse = TRUE)
        }
        else as(contrasts.arg, "sparseMatrix"), m)
    }
    ans
}


`.__T__is.na:base` <- "<environment>"

.__C__zMatrix <- new("classRepresentation", slots = list(x = structure("complex", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(Matrix = new("SClassExtension", subClass = "zMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("zMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xMatrix = new("SClassExtension", subClass = "zMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("zMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "zMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "mMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "mMatrix", dQuote("Matrix"), "mMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "zMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "zMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("zMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
        replValueSp = new("SClassExtension", subClass = "zMatrix", 
            superClass = "replValueSp", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("zMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 2)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("zMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


zapsmall <- new("standardGeneric", .Data = function (x, digits = getOption("digits")) 
standardGeneric("zapsmall"), generic = "zapsmall", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "digits"), default = new("derivedDefaultMethod", .Data = function (x, 
        digits = getOption("digits")) 
    {
        if (length(digits) == 0L) 
            stop("invalid 'digits'")
        if (all(ina <- is.na(x))) 
            return(x)
        mx <- max(abs(x[!ina]))
        round(x, digits = if (mx > 0) max(0L, digits - as.numeric(log10(mx))) else digits)
    }, target = new("signature", .Data = "ANY", names = "x", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), generic = "zapsmall"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        digits = getOption("digits")) 
    {
        if (length(digits) == 0L) 
            stop("invalid 'digits'")
        if (all(ina <- is.na(x))) 
            return(x)
        mx <- max(abs(x[!ina]))
        round(x, digits = if (mx > 0) max(0L, digits - as.numeric(log10(mx))) else digits)
    }, target = new("signature", .Data = "ANY", names = "x", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), generic = "zapsmall"))(x, 
        digits))


`.__T__-:base` <- "<environment>"

`.__T__diag<-:base` <- "<environment>"

cov2cor <- new("standardGeneric", .Data = function (V) 
standardGeneric("cov2cor"), generic = "cov2cor", package = "stats", 
    group = list(), valueClass = character(0), signature = "V", 
    default = new("derivedDefaultMethod", .Data = function (V) 
    {
        p <- (d <- dim(V))[1L]
        if (!is.numeric(V) || length(d) != 2L || p != d[2L]) 
            stop("'V' is not a square numeric matrix")
        Is <- sqrt(1/diag(V))
        if (any(!is.finite(Is))) 
            warning("diag(.) had 0 or NA entries; non-finite result is doubtful")
        r <- V
        r[] <- Is * V * rep(Is, each = p)
        r[cbind(1L:p, 1L:p)] <- 1
        r
    }, target = new("signature", .Data = "ANY", names = "V", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "V", package = "methods"), generic = "cov2cor"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (V) 
    {
        p <- (d <- dim(V))[1L]
        if (!is.numeric(V) || length(d) != 2L || p != d[2L]) 
            stop("'V' is not a square numeric matrix")
        Is <- sqrt(1/diag(V))
        if (any(!is.finite(Is))) 
            warning("diag(.) had 0 or NA entries; non-finite result is doubtful")
        r <- V
        r[] <- Is * V * rep(Is, each = p)
        r[cbind(1L:p, 1L:p)] <- 1
        r
    }, target = new("signature", .Data = "ANY", names = "V", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "V", package = "methods"), generic = "cov2cor"))(V))


sparseMatrix <- function (i = ep, j = ep, p, x, dims, dimnames, symmetric = FALSE, 
    triangular = FALSE, index1 = TRUE, giveCsparse = TRUE, check = TRUE, 
    use.last.ij = FALSE) 
{
    if ((m.i <- missing(i)) + (m.j <- missing(j)) + (m.p <- missing(p)) != 
        1) 
        stop("exactly one of 'i', 'j', or 'p' must be missing from call")
    if (!m.p) {
        p <- as.integer(p)
        if ((lp <- length(p)) < 1 || p[1] != 0 || any((dp <- p[-1] - 
            p[-lp]) < 0)) 
            stop("'p' must be a non-decreasing vector (0, ...)")
        ep <- rep.int(seq_along(dp), dp)
    }
    i1 <- as.logical(index1)[1]
    i <- as.integer(i + !(m.i || i1))
    j <- as.integer(j + !(m.j || i1))
    dims.min <- suppressWarnings(c(max(i), max(j)))
    if (anyNA(dims.min)) 
        stop("NA's in (i,j) are not allowed")
    if (missing(dims)) {
        dims <- if (symmetric || triangular) 
            rep(max(dims.min), 2)
        else dims.min
    }
    else {
        stopifnot(all(dims >= dims.min))
        dims <- as.integer(dims)
    }
    if (symmetric && triangular) 
        stop("Both 'symmetric' and 'triangular', i.e. asking for diagonal matrix.  Use 'Diagonal()' instead")
    sx <- if (symmetric) {
        if (dims[1] != dims[2]) 
            stop("symmetric matrix must be square")
        "s"
    }
    else if (triangular) {
        if (dims[1] != dims[2]) 
            stop("triangular matrix must be square")
        "t"
    }
    else "g"
    isPat <- missing(x)
    kx <- if (isPat) 
        "n"
    else .M.kind(x)
    r <- new(paste0(kx, sx, "TMatrix"))
    r@Dim <- dims
    if (symmetric && all(i >= j)) 
        r@uplo <- "L"
    else if (triangular) {
        r@uplo <- if (all(i >= j)) 
            "L"
        else if (all(i <= j)) 
            "U"
        else stop("triangular matrix must have all i >= j or i <= j")
    }
    if (!isPat) {
        if (kx == "d" && !is.double(x)) 
            x <- as.double(x)
        if (length(x) != (n <- length(i))) {
            if (length(x) != 1 && n%%length(x) != 0) 
                warning("length(i) is not a multiple of length(x)")
            x <- rep_len(x, n)
        }
        if (use.last.ij && (id <- anyDuplicated(cbind(i, j), 
            fromLast = TRUE))) {
            i <- i[-id]
            j <- j[-id]
            x <- x[-id]
            if (any(idup <- duplicated(cbind(i, j), fromLast = TRUE))) {
                ndup <- -which(idup)
                i <- i[ndup]
                j <- j[ndup]
                x <- x[ndup]
            }
        }
        r@x <- x
    }
    r@i <- i - 1L
    r@j <- j - 1L
    if (!missing(dimnames)) 
        r@Dimnames <- .fixupDimnames(dimnames)
    if (check) 
        validObject(r)
    if (giveCsparse) 
        as(r, "CsparseMatrix")
    else r
}


.__C__dppMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(dspMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = "dspMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "dspMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddenseMatrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 2), symmetricMatrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "symmetricMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dspMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dMatrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 3), denseMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 3), compMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dspMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), Matrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 4), mMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "dspMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 5), 
        xMatrix = new("SClassExtension", subClass = "dppMatrix", 
            superClass = "xMatrix", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    from <- {
                      class(from) <- "dspMatrix"
                      from
                    }
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "dMatrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                    dQuote(class(value))), domain = NA)
                value
            }, "dppMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
            distance = 4), Mnumeric = new("SClassExtension", 
            subClass = "dppMatrix", superClass = "Mnumeric", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dspMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dspMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(from, what) <- slot(value, 
                    what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 5), replValueSp = new("SClassExtension", 
            subClass = "dppMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dspMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dspMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(from, what) <- slot(value, 
                    what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 5)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dppMatrix_validate, object), access = list(), className = structure("dppMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__lgTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    TsparseMatrix = new("SClassExtension", subClass = "lgTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("lgTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("lgTMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lgTMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("lgTMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgTMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("lgTMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgTMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("lgTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgTMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lgTMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgTMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lgTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lgTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lgTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lgTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xTMatrix_validate, object), access = list(), className = structure("lgTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__dim:base` <- "<environment>"

.__C__CsparseMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    sparseMatrix = new("SClassExtension", subClass = "CsparseMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "CsparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "CsparseMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "CsparseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "CsparseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(Csparse_validate, object), access = list(), className = structure("CsparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dgCMatrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "CsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("dgCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtCMatrix = new("SClassExtension", subClass = "dtCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("dtCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsCMatrix = new("SClassExtension", subClass = "dsCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("dsCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgCMatrix = new("SClassExtension", subClass = "lgCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("lgCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltCMatrix = new("SClassExtension", subClass = "ltCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("ltCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsCMatrix = new("SClassExtension", subClass = "lsCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("lsCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngCMatrix = new("SClassExtension", subClass = "ngCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("ngCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntCMatrix = new("SClassExtension", subClass = "ntCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("ntCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsCMatrix = new("SClassExtension", subClass = "nsCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("nsCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__coerce:methods` <- "<environment>"

`.__T__unname:base` <- "<environment>"

which <- new("standardGeneric", .Data = function (x, arr.ind = FALSE, 
    useNames = TRUE) 
standardGeneric("which"), generic = "which", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "arr.ind", "useNames"), default = new("derivedDefaultMethod", 
        .Data = function (x, arr.ind = FALSE, useNames = TRUE) 
        {
            wh <- .Internal(which(x))
            if (arr.ind && !is.null(d <- dim(x))) 
                arrayInd(wh, d, dimnames(x), useNames = useNames)
            else wh
        }, target = new("signature", .Data = "ANY", names = "x", 
            package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "which"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (x, arr.ind = FALSE, useNames = TRUE) 
        {
            wh <- .Internal(which(x))
            if (arr.ind && !is.null(d <- dim(x))) 
                arrayInd(wh, d, dimnames(x), useNames = useNames)
            else wh
        }, target = new("signature", .Data = "ANY", names = "x", 
            package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "which"))(x, arr.ind, useNames))


.__C__RsparseMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    sparseMatrix = new("SClassExtension", subClass = "RsparseMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "RsparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "RsparseMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "RsparseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "RsparseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(Rsparse_validate, object), access = list(), className = structure("RsparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dgRMatrix = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "RsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("dgRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtRMatrix = new("SClassExtension", subClass = "dtRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("dtRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsRMatrix = new("SClassExtension", subClass = "dsRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("dsRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgRMatrix = new("SClassExtension", subClass = "lgRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("lgRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltRMatrix = new("SClassExtension", subClass = "ltRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("ltRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsRMatrix = new("SClassExtension", subClass = "lsRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("lsRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngRMatrix = new("SClassExtension", subClass = "ngRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("ngRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntRMatrix = new("SClassExtension", subClass = "ntRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("ntRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsRMatrix = new("SClassExtension", subClass = "nsRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("nsRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


KhatriRao <- function (X, Y = X, FUN = "*", make.dimnames = FALSE) 
{
    stopifnot((p <- ncol(X)) == ncol(Y))
    X <- as(X, "CsparseMatrix")
    Y <- as(Y, "CsparseMatrix")
    is.n <- (nX <- is(X, "nMatrix")) & (nY <- is(Y, "nMatrix"))
    xn <- diff(X@p)
    yn <- diff(yp <- Y@p)
    newp <- as.integer(diffinv(xn * yn))
    rep.yn <- rep.int(yn, xn)
    xn.yp <- xn[as.logical(yn)]
    non0 <- length(xn.yp) > 0L && any(xn.yp != 0L)
    i1 <- rep.int(X@i, rep.yn)
    i2 <- if (non0) {
        yj <- .Call(Matrix_expand_pointers, yp)
        yj <- factor(yj)
        unlist(rep(split.default(Y@i, yj), xn.yp))
    }
    else integer()
    n1 <- nrow(X)
    n2 <- nrow(Y)
    newi <- i1 * n2 + i2
    dim <- as.integer(c(n1 * n2, p))
    dns <- if (make.dimnames) {
        list(as.vector(outer(rownames(Y), rownames(X), FUN = "paste", 
            sep = ":")), colnames(X))
    }
    else list(NULL, NULL)
    if (is.n) 
        new("ngCMatrix", Dim = dim, Dimnames = dns, i = newi, 
            p = newp)
    else {
        if (nX) 
            X <- as(X, "lgCMatrix")
        x1 <- rep.int(X@x, rep.yn)
        x2 <- if (non0) {
            if (nY) 
                Y <- as(Y, "lgCMatrix")
            unlist(rep(split.default(Y@x, yj), xn.yp))
        }
        else if (nY) 
            logical()
        else Y@x[0]
        new("dgCMatrix", Dim = dim, Dimnames = dns, i = newi, 
            p = newp, x = match.fun(FUN)(x1, x2))
    }
}


mean <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("mean"), generic = "mean", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("mean"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "mean"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("mean"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "mean"))(x, 
        ...))


`.__T__dimnames<-:base` <- "<environment>"

colSums <- new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, 
    ...) 
standardGeneric("colSums"), generic = "colSums", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::colSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "colSums"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::colSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "colSums"))(x, 
        na.rm, dims, ...))


`.__T__colSums:base` <- "<environment>"

band <- new("standardGeneric", .Data = function (x, k1, k2, ...) 
standardGeneric("band"), generic = "band", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("x", 
    "k1", "k2"), default = NULL, skeleton = (function (x, k1, 
        k2, ...) 
    stop("invalid call in method dispatch to 'band' (no default method)", 
        domain = NA))(x, k1, k2, ...))


`.__T__format:base` <- "<environment>"

`.__T__head:utils` <- "<environment>"

.m2lgC <- function (from) 
{
    if (!is.logical(from)) 
        storage.mode(from) <- "logical"
    .Call(matrix_to_Csparse, from, "lgCMatrix")
}


`.__T__as.logical:base` <- "<environment>"

`.__T__%%:base` <- "<environment>"

.__C__ngRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(RsparseMatrix = new("SClassExtension", subClass = "ngRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("ngRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("ngRMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ngRMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("ngRMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngRMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("ngRMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngRMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ngRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngRMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("ngRMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngRMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ngRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ngRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ngRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ngRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ngRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


Schur <- new("standardGeneric", .Data = function (x, vectors, ...) 
standardGeneric("Schur"), generic = "Schur", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("x", 
    "vectors"), default = NULL, skeleton = (function (x, vectors, 
        ...) 
    stop("invalid call in method dispatch to 'Schur' (no default method)", 
        domain = NA))(x, vectors, ...))


`.__T__update:stats` <- "<environment>"

.__C__ltTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(TsparseMatrix = new("SClassExtension", subClass = "ltTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("ltTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("ltTMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("ltTMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ltTMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltTMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("ltTMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltTMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ltTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltTMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ltTMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltTMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ltTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ltTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ltTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ltTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ltTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ltTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tTMatrix_validate, object), access = list(), className = structure("ltTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


qr.qty <- new("standardGeneric", .Data = function (qr, y) 
standardGeneric("qr.qty"), generic = "qr.qty", package = "base", 
    group = list(), valueClass = character(0), signature = c("qr", 
    "y"), default = new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
        if (isTRUE(attr(qr, "useLAPACK"))) 
            return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        k <- as.integer(qr$rank)
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        storage.mode(y) <- "double"
        .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, qty = y)$qty
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.qty"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            return(.Internal(qr_qy_cmplx(qr, as.matrix(y), TRUE)))
        if (isTRUE(attr(qr, "useLAPACK"))) 
            return(.Internal(qr_qy_real(qr, as.matrix(y), TRUE)))
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        k <- as.integer(qr$rank)
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        storage.mode(y) <- "double"
        .Fortran(.F_dqrqty, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, qty = y)$qty
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.qty"))(qr, 
        y))


`.__T__summary:base` <- "<environment>"

..2dge <- function (from) 
.Call(dup_mMatrix_as_dgeMatrix, from)


`.__T__chol2inv:base` <- "<environment>"

.__C__rleDiff <- new("classRepresentation", slots = list(first = structure("numLike", package = "Matrix"), 
    rle = structure("rle", package = "methods")), contains = list(), 
    virtual = FALSE, prototype = S4_object(), validity = function (object) 
    {
        if (length(object@first) != 1) 
            return("'first' must be of length one")
        rl <- object@rle
        if (!is.list(rl) || length(rl) != 2 || !identical(sort(names(rl)), 
            c("lengths", "values"))) 
            return("'rle' must be a list (lengths = *, values = *)")
        if (length(lens <- rl$lengths) != length(vals <- rl$values)) 
            return("'lengths' and 'values' differ in length")
        if (any(lens <= 0)) 
            return("'lengths' must be positive")
        TRUE
    }, access = list(), className = structure("rleDiff", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


unname <- new("standardGeneric", .Data = function (obj, force = FALSE) 
standardGeneric("unname"), generic = "unname", package = "base", 
    group = list(), valueClass = character(0), signature = c("obj", 
    "force"), default = new("derivedDefaultMethod", .Data = function (obj, 
        force = FALSE) 
    {
        if (!is.null(names(obj))) 
            names(obj) <- NULL
        if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) 
            dimnames(obj) <- NULL
        obj
    }, target = new("signature", .Data = "ANY", names = "obj", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "obj", package = "methods"), generic = "unname"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (obj, 
        force = FALSE) 
    {
        if (!is.null(names(obj))) 
            names(obj) <- NULL
        if (!is.null(dimnames(obj)) && (force || !is.data.frame(obj))) 
            dimnames(obj) <- NULL
        obj
    }, target = new("signature", .Data = "ANY", names = "obj", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "obj", package = "methods"), generic = "unname"))(obj, 
        force))


.__C__ntpMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(ndenseMatrix = new("SClassExtension", subClass = "ntpMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ntpMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ntpMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntpMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = "ntpMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntpMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntpMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ntpMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntpMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ntpMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "ndenseMatrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "ntpMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ntpMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__[<-:base` <- "<environment>"

`.__T__tril:Matrix` <- "<environment>"

.dsy2dsp <- function (from) 
.Call(dsyMatrix_as_dspMatrix, from)


rep2abI <- function (x, times) 
{
    r <- new("abIndex")
    if ((n <- length(x)) == 0) 
        return(r)
    if (n == 1) {
        r@kind <- "rleDiff"
        rD <- new("rleDiff")
        rD@first <- x[1L]
        rD@rle <- .rle(lengths = times - 1L, values = 0L)
        r@rleD <- rD
    }
    else {
        rr <- rleMaybe(.diff(x))
        if (is.null(rr)) {
            r@kind <- if (is.integer(x)) 
                "int32"
            else "double"
            r@x <- rep.int(x, times)
        }
        else {
            r@kind <- "rleDiff"
            rD <- new("rleDiff")
            rD@first <- x[1L]
            Dx <- x[1L] - x[length(x)]
            N <- (length(rr$lengths) + 1L) * times
            rD@rle <- .rle(lengths = rep.int(c(rr$lengths, 1L), 
                times)[-N], values = rep.int(c(rr$values, Dx), 
                times)[-N])
            r@rleD <- rD
        }
    }
    r
}


.__C__triangularMatrix <- new("classRepresentation", slots = list(uplo = structure("character", package = "methods"), 
    diag = structure("character", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    Matrix = new("SClassExtension", subClass = "triangularMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "triangularMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    Mnumeric = new("SClassExtension", subClass = "triangularMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    replValueSp = new("SClassExtension", subClass = "triangularMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2)), 
    virtual = TRUE, prototype = S4_object(), validity = function (object) 
    .Call(triangularMatrix_validate, object), access = list(), 
    className = structure("triangularMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dtrMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = "triangularMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtrMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtpMatrix = new("SClassExtension", subClass = "dtpMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtpMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltrMatrix = new("SClassExtension", subClass = "ltrMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltrMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltpMatrix = new("SClassExtension", subClass = "ltpMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltpMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntrMatrix = new("SClassExtension", subClass = "ntrMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntrMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntpMatrix = new("SClassExtension", subClass = "ntpMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntpMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtTMatrix = new("SClassExtension", subClass = "dtTMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtTMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtCMatrix = new("SClassExtension", subClass = "dtCMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtCMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtRMatrix = new("SClassExtension", subClass = "dtRMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtRMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltTMatrix = new("SClassExtension", subClass = "ltTMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltTMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltCMatrix = new("SClassExtension", subClass = "ltCMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltCMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltRMatrix = new("SClassExtension", subClass = "ltRMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltRMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntTMatrix = new("SClassExtension", subClass = "ntTMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntTMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntCMatrix = new("SClassExtension", subClass = "ntCMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntCMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntRMatrix = new("SClassExtension", subClass = "ntRMatrix", 
        superClass = "triangularMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntRMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Cholesky = new("SClassExtension", subClass = "Cholesky", 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), pCholesky = new("SClassExtension", 
        subClass = "pCholesky", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


qr.coef <- new("standardGeneric", .Data = function (qr, y) 
standardGeneric("qr.coef"), generic = "qr.coef", package = "base", 
    group = list(), valueClass = character(0), signature = c("qr", 
    "y"), default = new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("first argument must be a QR decomposition")
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        p <- as.integer(ncol(qr$qr))
        if (is.na(p)) 
            stop("invalid ncol(qr$qr)")
        k <- as.integer(qr$rank)
        if (is.na(k)) 
            stop("invalid ncol(qr$rank)")
        im <- is.matrix(y)
        if (!im) 
            y <- as.matrix(y)
        ny <- as.integer(ncol(y))
        if (is.na(ny)) 
            stop("invalid ncol(y)")
        if (nrow(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        isC <- is.complex(qr$qr)
        coef <- matrix(if (isC) 
            NA_complex_
        else NA_real_, p, ny)
        ix <- if (p > n) 
            c(seq_len(n), rep(NA, p - n))
        else seq_len(p)
        if (!is.null(nam <- colnames(qr$qr))) 
            pivotted <- NA
        if (p == 0L) {
            pivotted <- FALSE
        }
        else if (isC) {
            coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, 
                ]
        }
        else if (isTRUE(attr(qr, "useLAPACK"))) {
            coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, 
                ]
        }
        else if (k > 0L) {
            storage.mode(y) <- "double"
            z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), 
                y, ny, coef = matrix(0, nrow = k, ncol = ny), 
                info = integer(1L), NAOK = TRUE)[c("coef", "info")]
            if (z$info) 
                stop("exact singularity in 'qr.coef'")
            pivotted <- k < p
            if (pivotted) 
                coef[qr$pivot[seq_len(k)], ] <- z$coef
            else coef <- z$coef
        }
        if (!is.null(nam)) {
            if (is.na(pivotted)) 
                pivotted <- is.unsorted(qr$pivot)
            if (pivotted) 
                rownames(coef)[qr$pivot] <- nam
            else rownames(coef) <- nam
        }
        if (im && !is.null(nam <- colnames(y))) 
            colnames(coef) <- nam
        if (im) 
            coef
        else drop(coef)
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.coef"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("first argument must be a QR decomposition")
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        p <- as.integer(ncol(qr$qr))
        if (is.na(p)) 
            stop("invalid ncol(qr$qr)")
        k <- as.integer(qr$rank)
        if (is.na(k)) 
            stop("invalid ncol(qr$rank)")
        im <- is.matrix(y)
        if (!im) 
            y <- as.matrix(y)
        ny <- as.integer(ncol(y))
        if (is.na(ny)) 
            stop("invalid ncol(y)")
        if (nrow(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        isC <- is.complex(qr$qr)
        coef <- matrix(if (isC) 
            NA_complex_
        else NA_real_, p, ny)
        ix <- if (p > n) 
            c(seq_len(n), rep(NA, p - n))
        else seq_len(p)
        if (!is.null(nam <- colnames(qr$qr))) 
            pivotted <- NA
        if (p == 0L) {
            pivotted <- FALSE
        }
        else if (isC) {
            coef[qr$pivot, ] <- .Internal(qr_coef_cmplx(qr, y))[ix, 
                ]
        }
        else if (isTRUE(attr(qr, "useLAPACK"))) {
            coef[qr$pivot, ] <- .Internal(qr_coef_real(qr, y))[ix, 
                ]
        }
        else if (k > 0L) {
            storage.mode(y) <- "double"
            z <- .Fortran(.F_dqrcf, as.double(qr$qr), n, k, as.double(qr$qraux), 
                y, ny, coef = matrix(0, nrow = k, ncol = ny), 
                info = integer(1L), NAOK = TRUE)[c("coef", "info")]
            if (z$info) 
                stop("exact singularity in 'qr.coef'")
            pivotted <- k < p
            if (pivotted) 
                coef[qr$pivot[seq_len(k)], ] <- z$coef
            else coef <- z$coef
        }
        if (!is.null(nam)) {
            if (is.na(pivotted)) 
                pivotted <- is.unsorted(qr$pivot)
            if (pivotted) 
                rownames(coef)[qr$pivot] <- nam
            else rownames(coef) <- nam
        }
        if (im && !is.null(nam <- colnames(y))) 
            colnames(coef) <- nam
        if (im) 
            coef
        else drop(coef)
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.coef"))(qr, 
        y))


.__C__abIndex <- new("classRepresentation", slots = list(kind = structure("character", package = "methods"), 
    x = structure("numLike", package = "Matrix"), rleD = structure("rleDiff", package = "Matrix")), 
    contains = list(), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        switch(object@kind, int32 = if (!is.integer(object@x)) return("'x' slot must be integer when kind is 'int32'"), 
            double = if (!is.double(object@x)) return("'x' slot must be double when kind is 'double'"), 
            rleDiff = {
                if (length(object@x)) return("'x' slot must be empty when kind is 'rleDiff'")
            }, return("'kind' must be one of (\"int32\", \"double\", \"rleDiff\")"))
        TRUE
    }, access = list(), className = structure("abIndex", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__pBunchKaufman <- new("classRepresentation", slots = list(perm = structure("integer", package = "methods"), 
    x = structure("numeric", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    diag = structure("character", package = "methods")), contains = list(
    dtpMatrix = new("SClassExtension", subClass = "pBunchKaufman", 
        superClass = "dtpMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            value <- new("dtpMatrix")
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(value, what) <- slot(from, what)
            value
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), MatrixFactorization = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("pBunchKaufman"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddenseMatrix = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 2), triangularMatrix = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dMatrix = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3), denseMatrix = new("SClassExtension", subClass = "pBunchKaufman", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3), Matrix = new("SClassExtension", subClass = "pBunchKaufman", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtpMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4), 
    xMatrix = new("SClassExtension", subClass = "pBunchKaufman", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtpMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dMatrix", dataPart = FALSE, distance = 4), 
    Mnumeric = new("SClassExtension", subClass = "pBunchKaufman", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtpMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4), 
    replValueSp = new("SClassExtension", subClass = "pBunchKaufman", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtpMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4)), 
    virtual = FALSE, prototype = S4_object(), validity = function (object) 
    .Call(pBunchKaufman_validate, object), access = list(), className = structure("pBunchKaufman", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__CHMsuper <- new("classRepresentation", slots = list(super = structure("integer", package = "methods"), 
    pi = structure("integer", package = "methods"), px = structure("integer", package = "methods"), 
    s = structure("integer", package = "methods"), colcount = structure("integer", package = "methods"), 
    perm = structure("integer", package = "methods"), type = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods")), contains = list(
    CHMfactor = new("SClassExtension", subClass = "CHMsuper", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsuper"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CholeskyFactorization = new("SClassExtension", 
        subClass = "CHMsuper", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), simple = TRUE, by = "CHMfactor", dataPart = FALSE, 
        distance = 2), MatrixFactorization = new("SClassExtension", 
        subClass = "CHMsuper", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), "CHMsuper"), simple = TRUE, by = "CHMfactor", 
        dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(CHMsuper_validate, object), access = list(), className = structure("CHMsuper", package = "Matrix"), 
    package = "Matrix", subclasses = list(dCHMsuper = new("SClassExtension", 
        subClass = "dCHMsuper", superClass = "CHMsuper", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsuper")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsuper", dQuote("dCHMsuper"), "CHMsuper", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nCHMsuper = new("SClassExtension", subClass = "nCHMsuper", 
        superClass = "CHMsuper", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsuper")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsuper", dQuote("nCHMsuper"), "CHMsuper", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


Diagonal <- function (n, x = NULL) 
{
    n <- if (missing(n)) 
        length(x)
    else {
        stopifnot(length(n) == 1, n == as.integer(n), n >= 0)
        as.integer(n)
    }
    if (missing(x)) 
        new("ddiMatrix", Dim = c(n, n), diag = "U")
    else {
        lx <- length(x)
        lx.1 <- lx == 1L
        stopifnot(lx.1 || lx == n)
        if (is.logical(x)) 
            cl <- "ldiMatrix"
        else if (is.numeric(x)) {
            cl <- "ddiMatrix"
            x <- as.numeric(x)
        }
        else if (is.complex(x)) {
            cl <- "zdiMatrix"
        }
        else stop("'x' has invalid data type")
        if (lx.1 && !is.na(x) && x == 1) 
            new(cl, Dim = c(n, n), diag = "U")
        else new(cl, Dim = c(n, n), diag = "N", x = if (lx.1) 
            rep.int(x, n)
        else x)
    }
}


.__C__nsyMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(ndenseMatrix = new("SClassExtension", subClass = "nsyMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("nsyMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("nsyMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsyMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = "nsyMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsyMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsyMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("nsyMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsyMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nsyMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("nsyMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "ndenseMatrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "nsyMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("nsyMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__Math:base` <- "<environment>"

qrR <- function (qr, complete = FALSE, backPermute = TRUE, row.names = TRUE) 
{
    ir <- seq_len(qr@Dim[if (complete) 1L else 2L])
    r <- if (backPermute <- backPermute && (n <- length(qr@q)) && 
        !isSeq(qr@q, n - 1L)) 
        qr@R[ir, order(qr@q), drop = FALSE]
    else qr@R[ir, , drop = FALSE]
    if (row.names && !is.null(rn <- qr@V@Dimnames[[1]])) 
        r@Dimnames[[1]] <- rn[seq_len(r@Dim[1L])]
    if (complete || backPermute) 
        r
    else as(r, "triangularMatrix")
}


.__C__lsTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(TsparseMatrix = new("SClassExtension", subClass = "lsTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("lsTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("lsTMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lsTMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("lsTMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsTMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("lsTMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsTMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("lsTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsTMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lsTMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsTMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tTMatrix_validate, object), access = list(), className = structure("lsTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


rowSums <- new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, 
    ...) 
standardGeneric("rowSums"), generic = "rowSums", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::rowSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "rowSums"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::rowSums(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "rowSums"))(x, 
        na.rm, dims, ...))


skewpart <- new("standardGeneric", .Data = function (x) 
standardGeneric("skewpart"), generic = "skewpart", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x) 
    stop("invalid call in method dispatch to 'skewpart' (no default method)", 
        domain = NA))(x))


.diag.dsC <- function (x, Chx = Cholesky(x, LDL = TRUE), res.kind = "diag") 
{
    force(Chx)
    if (!missing(Chx)) 
        stopifnot(.isLDL(Chx), is.integer(Chx@p), is.double(Chx@x))
    .Call(diag_tC, Chx, res.kind)
}


.__C__ngeMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    ndenseMatrix = new("SClassExtension", subClass = "ngeMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ngeMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("ngeMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngeMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), geMatrix = new("SClassExtension", subClass = "ngeMatrix", 
        superClass = "geMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "geMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "geMatrix", dQuote("ngeMatrix"), "geMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = "ngeMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngeMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngeMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), xMatrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("ndenseMatrix"), "xMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngeMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("ngeMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngeMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ngeMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ngeMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ngeMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ngeMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("ngeMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__ntRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    diag = structure("character", package = "methods")), contains = list(
    RsparseMatrix = new("SClassExtension", subClass = "ntRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("ntRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("ntRMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ntRMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ntRMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntRMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("ntRMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntRMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ntRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntRMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ntRMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntRMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ntRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ntRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ntRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ntRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ntRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ntRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ntRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__kronecker:base` <- "<environment>"

.__C__dpoMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(dsyMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "dsyMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "dsyMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddenseMatrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 2), symmetricMatrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "symmetricMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dsyMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dMatrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 3), denseMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 3), compMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dsyMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), Matrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 4), mMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 5), 
        xMatrix = new("SClassExtension", subClass = "dpoMatrix", 
            superClass = "xMatrix", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    from <- {
                      class(from) <- "dsyMatrix"
                      from
                    }
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "dMatrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                    dQuote(class(value))), domain = NA)
                value
            }, "dpoMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
            distance = 4), Mnumeric = new("SClassExtension", 
            subClass = "dpoMatrix", superClass = "Mnumeric", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dsyMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dsyMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(from, what) <- slot(value, 
                    what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 5), replValueSp = new("SClassExtension", 
            subClass = "dpoMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dsyMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dsyMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(from, what) <- slot(value, 
                    what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 5)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dpoMatrix_validate, object), access = list(), className = structure("dpoMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(corMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = "dpoMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            value <- new("dpoMatrix")
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(value, what) <- slot(from, what)
            value
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


head <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("head"), generic = "head", package = "utils", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("head"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "head"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("head"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "head"))(x, 
        ...))


printSpMatrix <- function (x, digits = NULL, maxp = max(100L, getOption("max.print")), 
    cld = getClassDef(class(x)), zero.print = ".", col.names, 
    note.dropping.colnames = TRUE, uniDiag = TRUE, col.trailer = "", 
    align = c("fancy", "right")) 
{
    stopifnot(extends(cld, "sparseMatrix"))
    cx <- formatSpMatrix(x, digits = digits, maxp = maxp, cld = cld, 
        zero.print = zero.print, col.names = col.names, note.dropping.colnames = note.dropping.colnames, 
        uniDiag = uniDiag, align = align)
    if (col.trailer != "") 
        cx <- cbind(cx, col.trailer, deparse.level = 0)
    print(cx, quote = FALSE, right = TRUE, max = maxp)
    invisible(x)
}


`.__T__all:base` <- "<environment>"

`.__T__as.integer:base` <- "<environment>"

.__C__nsCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    CsparseMatrix = new("SClassExtension", subClass = "nsCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("nsCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("nsCMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("nsCMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("nsCMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsCMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nCsparseMatrix = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "nCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nCsparseMatrix", dQuote("nsCMatrix"), "nCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("nsCMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsCMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("nsCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsCMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("nsCMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsCMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "nsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "nsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "nsCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "nsCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("nsCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.solve.dgC.qr <- function (x, y, order = 1L) 
{
    cld <- getClass(class(x))
    .Call(dgCMatrix_qrsol, if (extends(cld, "dgCMatrix") || extends(cld, 
        "dtCMatrix")) x else as(x, "dgCMatrix"), y, order)
}


.__C__nspMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(ndenseMatrix = new("SClassExtension", subClass = "nspMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("nspMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("nspMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nspMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = "nspMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nspMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nspMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("nspMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nspMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nspMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("nspMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "ndenseMatrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "nspMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "nspMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dspMatrix_validate, object), access = list(), className = structure("nspMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__qr.R:base` <- "<environment>"

.__C__zsparseVector <- new("classRepresentation", slots = list(x = structure("complex", package = "methods"), 
    length = structure("numeric", package = "methods"), i = structure("numeric", package = "methods")), 
    contains = list(sparseVector = new("SClassExtension", subClass = "zsparseVector", 
        superClass = "sparseVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("zsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xsparseVector = new("SClassExtension", 
        subClass = "zsparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("zsparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), replValueSp = new("SClassExtension", subClass = "zsparseVector", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("zsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "sparseVector", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        if (length(object@i) != length(object@x)) 
            "'i' and 'x' differ in length"
        else TRUE
    }, access = list(), className = structure("zsparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__ltCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(CsparseMatrix = new("SClassExtension", subClass = "ltCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("ltCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("ltCMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltCMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lCsparseMatrix = new("SClassExtension", 
        subClass = "ltCMatrix", superClass = "lCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lCsparseMatrix", dQuote("ltCMatrix"), "lCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltCMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltCMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), xMatrix = new("SClassExtension", 
        subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("lMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lsparseMatrix"), "ltCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = structure("ltCMatrix", package = "Matrix"), 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltCMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 3), Mnumeric = new("SClassExtension", 
        subClass = "ltCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ltCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ltCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ltCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xCMatrix_validate, object), access = list(), className = structure("ltCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


drop <- new("standardGeneric", .Data = function (x) 
standardGeneric("drop"), generic = "drop", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x) 
    .Internal(drop(x)), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "drop"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x) 
    .Internal(drop(x)), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "drop"))(x))


.__C__sparseVector <- new("classRepresentation", slots = list(length = structure("numeric", package = "methods"), 
    i = structure("numeric", package = "methods")), contains = list(
    replValueSp = new("SClassExtension", subClass = "sparseVector", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValueSp")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValueSp", dQuote("sparseVector"), "replValueSp", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    {
        n <- object@length
        if (anyNA(i <- object@i)) 
            "'i' slot has NAs"
        else if (any(!is.finite(i))) 
            "'i' slot is not all finite"
        else if (any(i < 1)) 
            "'i' must be >= 1"
        else if (n == 0 && length(i)) 
            "'i' must be empty when the object length is zero"
        else if (any(i > n)) 
            sprintf("'i' must be in 1:%d", n)
        else if (is.unsorted(i, strictly = TRUE)) 
            "'i' must be sorted strictly increasingly"
        else TRUE
    }, access = list(), className = structure("sparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(dsparseVector = new("SClassExtension", 
        subClass = "dsparseVector", superClass = "sparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("dsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), isparseVector = new("SClassExtension", 
        subClass = "isparseVector", superClass = "sparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("isparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseVector = new("SClassExtension", 
        subClass = "lsparseVector", superClass = "sparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("lsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), zsparseVector = new("SClassExtension", 
        subClass = "zsparseVector", superClass = "sparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("zsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseVector = new("SClassExtension", 
        subClass = "nsparseVector", superClass = "sparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("nsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__qr:base` <- "<environment>"

rankMatrix <- function (x, tol = NULL, method = c("tolNorm2", "qr.R", "qrLINPACK", 
    "qr", "useGrad", "maybeGrad"), sval = svd(x, 0, 0)$d, warn.t = TRUE) 
{
    stopifnot(length(d <- dim(x)) == 2)
    p <- min(d)
    method <- match.arg(method)
    if (useGrad <- (method %in% c("useGrad", "maybeGrad"))) {
        stopifnot(length(sval) == p, diff(sval) <= 0)
        if (sval[1] == 0) {
            useGrad <- FALSE
            method <- eval(formals()[["method"]])[[1]]
        }
        else {
            ln.av <- log(abs(sval))
            diff1 <- diff(ln.av)
            if (method == "maybeGrad") {
                grad <- (min(ln.av) - max(ln.av))/p
                useGrad <- !is.na(grad) && min(diff1) <= min(-3, 
                  10 * grad)
            }
        }
    }
    if (!useGrad) {
        x.dense <- is.numeric(x) || is(x, "denseMatrix")
        if ((Meth <- method) == "qr") 
            method <- if (x.dense) 
                "qrLINPACK"
            else "qr.R"
        else Meth <- substr(method, 1, 2)
        if (Meth == "qr") {
            if (is.null(tol)) 
                tol <- max(d) * .Machine$double.eps
        }
        else {
            if (is.null(tol)) {
                if (!x.dense && missing(sval) && prod(d) >= 100000L) 
                  warning(gettextf("rankMatrix(<large sparse Matrix>, method = '%s') coerces to dense matrix.\n Probably should rather use method = 'qr' !?", 
                    method), immediate. = TRUE, domain = NA)
                stopifnot(diff(sval) <= 0)
                tol <- max(d) * .Machine$double.eps
            }
            else stopifnot((tol <- as.numeric(tol)[[1]]) >= 0)
        }
    }
    structure(if (useGrad) 
        which.min(diff1)
    else if (Meth == "qr") {
        if ((do.t <- (d[1L] < d[2L])) && warn.t) 
            warning(gettextf("rankMatrix(x, method='qr'): computing t(x) as nrow(x) < ncol(x)"))
        q.r <- qr(if (do.t) 
            t(x)
        else x, tol = tol, LAPACK = method != "qrLINPACK")
        if (x.dense && (method == "qrLINPACK")) 
            q.r$rank
        else {
            diagR <- if (x.dense) 
                diag(q.r$qr)
            else diag(q.r@R)
            d.i <- abs(diagR)
            if ((mdi <- max(d.i)) > 0) 
                sum(d.i >= tol * mdi)
            else 0L
        }
    }
    else if (sval[1] > 0) 
        sum(sval >= tol * sval[1])
    else 0L, method = method, useGrad = useGrad, tol = if (useGrad) 
        NA
    else tol)
}


rbind2 <- methods::rbind2 # re-exported from methods package

.__C__BunchKaufman <- new("classRepresentation", slots = list(perm = structure("integer", package = "methods"), 
    x = structure("numeric", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    diag = structure("character", package = "methods")), contains = list(
    dtrMatrix = new("SClassExtension", subClass = "BunchKaufman", 
        superClass = "dtrMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            value <- new("dtrMatrix")
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(value, what) <- slot(from, what)
            value
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), MatrixFactorization = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("BunchKaufman"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddenseMatrix = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 2), triangularMatrix = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dMatrix = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), denseMatrix = new("SClassExtension", subClass = "BunchKaufman", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), Matrix = new("SClassExtension", subClass = "BunchKaufman", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtrMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4), 
    xMatrix = new("SClassExtension", subClass = "BunchKaufman", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtrMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dMatrix", dataPart = FALSE, distance = 4), 
    Mnumeric = new("SClassExtension", subClass = "BunchKaufman", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtrMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4), 
    replValueSp = new("SClassExtension", subClass = "BunchKaufman", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dtrMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(value, what) <- slot(from, what)
                  value
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4)), 
    virtual = FALSE, prototype = S4_object(), validity = function (object) 
    .Call(BunchKaufman_validate, object), access = list(), className = structure("BunchKaufman", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


rsparsematrix <- function (nrow, ncol, density, nnz = round(density * maxE), symmetric = FALSE, 
    rand.x = function(n) signif(rnorm(n), 2), ...) 
{
    maxE <- if (symmetric) 
        nrow * (nrow + 1)/2
    else nrow * ncol
    stopifnot((nnz <- as.integer(nnz)) >= 0, nrow >= 0, ncol >= 
        0, nnz <= maxE)
    ijI <- -1L + if (symmetric) 
        sample(indTri(nrow, diag = TRUE), nnz)
    else sample.int(maxE, nnz)
    if (is.null(rand.x)) 
        sparseMatrix(i = ijI%%nrow, j = ijI%/%nrow, index1 = FALSE, 
            symmetric = symmetric, dims = c(nrow, ncol), ...)
    else sparseMatrix(i = ijI%%nrow, j = ijI%/%nrow, index1 = FALSE, 
        symmetric = symmetric, x = rand.x(nnz), dims = c(nrow, 
            ncol), ...)
}


Cholesky <- new("standardGeneric", .Data = function (A, perm = TRUE, LDL = !super, 
    super = FALSE, Imult = 0, ...) 
standardGeneric("Cholesky"), generic = "Cholesky", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("A", 
    "perm", "LDL", "super", "Imult"), default = NULL, skeleton = (function (A, 
        perm = TRUE, LDL = !super, super = FALSE, Imult = 0, 
        ...) 
    stop("invalid call in method dispatch to 'Cholesky' (no default method)", 
        domain = NA))(A, perm, LDL, super, Imult, ...))


qr.resid <- new("standardGeneric", .Data = function (qr, y) 
standardGeneric("qr.resid"), generic = "qr.resid", package = "base", 
    group = list(), valueClass = character(0), signature = c("qr", 
    "y"), default = new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            stop("not implemented for complex 'qr'")
        if (isTRUE(attr(qr, "useLAPACK"))) 
            stop("not supported for LAPACK QR")
        k <- as.integer(qr$rank)
        if (k == 0) 
            return(y)
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        storage.mode(y) <- "double"
        .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, rsd = y)$rsd
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.resid"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            stop("not implemented for complex 'qr'")
        if (isTRUE(attr(qr, "useLAPACK"))) 
            stop("not supported for LAPACK QR")
        k <- as.integer(qr$rank)
        if (k == 0) 
            return(y)
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        storage.mode(y) <- "double"
        .Fortran(.F_dqrrsd, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, rsd = y)$rsd
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.resid"))(qr, 
        y))


.diag2mat <- function (from) 
mkDiag(if (from@diag == "U") as1(from@x) else from@x, n = from@Dim[1])


.__C__nsRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    RsparseMatrix = new("SClassExtension", subClass = "nsRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("nsRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("nsRMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("nsRMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("nsRMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsRMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("nsRMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsRMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("nsRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsRMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("nsRMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsRMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "nsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "nsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "nsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "nsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("nsRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__dgTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    TsparseMatrix = new("SClassExtension", subClass = "dgTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("dgTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dgTMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dgTMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("dgTMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgTMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dgTMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgTMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dgTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgTMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dgTMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgTMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dgTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dgTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dgTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dgTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xTMatrix_validate, object), access = list(), className = structure("dgTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__dimnames:base` <- "<environment>"

.dsy2mat <- function (from, keep.dimnames = TRUE) 
.Call(dsyMatrix_as_matrix, from, keep.dimnames)


.__C__Cholesky <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(dtrMatrix = new("SClassExtension", subClass = "Cholesky", 
        superClass = "dtrMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "dtrMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CholeskyFactorization = new("SClassExtension", 
        subClass = structure("Cholesky", package = "Matrix"), 
        superClass = structure("CholeskyFactorization", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("Cholesky"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddenseMatrix = new("SClassExtension", 
        subClass = "Cholesky", superClass = "ddenseMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 2), triangularMatrix = new("SClassExtension", 
        subClass = "Cholesky", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), MatrixFactorization = new("SClassExtension", 
        subClass = structure("Cholesky", package = "Matrix"), 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "Cholesky"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 2), dMatrix = new("SClassExtension", 
        subClass = "Cholesky", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), denseMatrix = new("SClassExtension", subClass = "Cholesky", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), Matrix = new("SClassExtension", subClass = "Cholesky", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "Cholesky", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "dtrMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4), 
        xMatrix = new("SClassExtension", subClass = "Cholesky", 
            superClass = "xMatrix", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dtrMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dtrMatrix", TRUE)
                as(.value, "dMatrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(from, what) <- slot(value, what)
                  from
                }
            }, simple = TRUE, by = "dMatrix", dataPart = FALSE, 
            distance = 4), Mnumeric = new("SClassExtension", 
            subClass = "Cholesky", superClass = "Mnumeric", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dtrMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dtrMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(from, what) <- slot(value, what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 4), replValueSp = new("SClassExtension", 
            subClass = "Cholesky", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dtrMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dtrMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(from, what) <- slot(value, what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("Cholesky", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


tcrossprod <- new("standardGeneric", .Data = function (x, y = NULL, ...) 
standardGeneric("tcrossprod"), generic = "tcrossprod", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "y"), default = new("derivedDefaultMethod", .Data = function (x, 
        y = NULL, ...) 
    base::tcrossprod(x, y), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "tcrossprod"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        y = NULL, ...) 
    base::tcrossprod(x, y), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "tcrossprod"))(x, 
        y, ...))


`.__T__qr.fitted:base` <- "<environment>"

`.__T__cov2cor:stats` <- "<environment>"

`.__T__updown:Matrix` <- "<environment>"

`.__T__is.infinite:base` <- "<environment>"

.__C__denseMatrix <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    Matrix = new("SClassExtension", subClass = "denseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "denseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    Mnumeric = new("SClassExtension", subClass = "denseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    replValueSp = new("SClassExtension", subClass = "denseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2)), 
    virtual = TRUE, prototype = S4_object(), validity = NULL, 
    access = list(), className = structure("denseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ddenseMatrix = new("SClassExtension", 
        subClass = "ddenseMatrix", superClass = "denseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ldenseMatrix = new("SClassExtension", 
        subClass = "ldenseMatrix", superClass = "denseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ndenseMatrix = new("SClassExtension", 
        subClass = "ndenseMatrix", superClass = "denseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgeMatrix = new("SClassExtension", subClass = "dgeMatrix", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgeMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dtrMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtrMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dtpMatrix = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtpMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dsyMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsyMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dspMatrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dspMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), dpoMatrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 3), dppMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 3), lgeMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgeMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), ltrMatrix = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltrMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), ltpMatrix = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltpMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), lsyMatrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsyMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), lspMatrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lspMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), ngeMatrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngeMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), ntrMatrix = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntrMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), ntpMatrix = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntpMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), nsyMatrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsyMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), nspMatrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nspMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), corMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 4), Cholesky = new("SClassExtension", subClass = "Cholesky", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), pCholesky = new("SClassExtension", subClass = "pCholesky", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE)


qr.Q <- new("standardGeneric", .Data = function (qr, complete = FALSE, 
    Dvec) 
standardGeneric("qr.Q"), generic = "qr.Q", package = "base", 
    group = list(), valueClass = character(0), signature = c("qr", 
    "complete", "Dvec"), default = new("derivedDefaultMethod", 
        .Data = function (qr, complete = FALSE, Dvec) 
        {
            if (!is.qr(qr)) 
                stop("argument is not a QR decomposition")
            dqr <- dim(qr$qr)
            n <- dqr[1L]
            cmplx <- mode(qr$qr) == "complex"
            if (missing(Dvec)) 
                Dvec <- rep.int(if (cmplx) 
                  1 + (0+0i)
                else 1, if (complete) 
                  n
                else min(dqr))
            D <- if (complete) 
                diag(Dvec, n)
            else {
                ncols <- min(dqr)
                diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
            }
            qr.qy(qr, D)
        }, target = new("signature", .Data = "ANY", names = "qr", 
            package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "qr", package = "methods"), 
        generic = "qr.Q"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (qr, complete = FALSE, Dvec) 
        {
            if (!is.qr(qr)) 
                stop("argument is not a QR decomposition")
            dqr <- dim(qr$qr)
            n <- dqr[1L]
            cmplx <- mode(qr$qr) == "complex"
            if (missing(Dvec)) 
                Dvec <- rep.int(if (cmplx) 
                  1 + (0+0i)
                else 1, if (complete) 
                  n
                else min(dqr))
            D <- if (complete) 
                diag(Dvec, n)
            else {
                ncols <- min(dqr)
                diag(Dvec[seq_len(ncols)], nrow = n, ncol = ncols)
            }
            qr.qy(qr, D)
        }, target = new("signature", .Data = "ANY", names = "qr", 
            package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "qr", package = "methods"), 
        generic = "qr.Q"))(qr, complete, Dvec))


qr.R <- new("standardGeneric", .Data = function (qr, complete = FALSE, 
    ...) 
standardGeneric("qr.R"), generic = "qr.R", package = "base", 
    group = list(), valueClass = character(0), signature = "qr", 
    default = new("derivedDefaultMethod", .Data = function (qr, 
        complete = FALSE, ...) 
    base::qr.R(qr, complete = complete), target = new("signature", 
        .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "qr", package = "methods"), generic = "qr.R"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (qr, 
        complete = FALSE, ...) 
    base::qr.R(qr, complete = complete), target = new("signature", 
        .Data = "ANY", names = "qr", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "qr", package = "methods"), generic = "qr.R"))(qr, 
        complete, ...))


`.__T__prod:base` <- "<environment>"

forceSymmetric <- new("standardGeneric", .Data = function (x, uplo) 
standardGeneric("forceSymmetric"), generic = "forceSymmetric", 
    package = "Matrix", group = list(), valueClass = character(0), 
    signature = c("x", "uplo"), default = NULL, skeleton = (function (x, 
        uplo) 
    stop("invalid call in method dispatch to 'forceSymmetric' (no default method)", 
        domain = NA))(x, uplo))


.__C__ntrMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(ndenseMatrix = new("SClassExtension", subClass = "ntrMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ntrMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ntrMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntrMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = "ntrMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntrMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntrMatrix"), simple = TRUE, by = structure("ndenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ntrMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntrMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ntrMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "ndenseMatrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "ntrMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("ntrMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__lsparseVector <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    length = structure("numeric", package = "methods"), i = structure("numeric", package = "methods")), 
    contains = list(sparseVector = new("SClassExtension", subClass = "lsparseVector", 
        superClass = "sparseVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("lsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xsparseVector = new("SClassExtension", 
        subClass = "lsparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("lsparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), replValueSp = new("SClassExtension", subClass = "lsparseVector", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("lsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "sparseVector", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        if (length(object@i) != length(object@x)) 
            "'i' and 'x' differ in length"
        else TRUE
    }, access = list(), className = structure("lsparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


Logic <- methods::Logic # re-exported from methods package

diag <- new("standardGeneric", .Data = function (x = 1, nrow, ncol, names = TRUE) 
standardGeneric("diag"), generic = "diag", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "nrow", "ncol", "names"), default = new("derivedDefaultMethod", 
        .Data = function (x = 1, nrow, ncol, names = TRUE) 
        {
            if (is.matrix(x)) {
                if (nargs() > 1L && (nargs() > 2L || any(names(match.call()) %in% 
                  c("nrow", "ncol")))) 
                  stop("'nrow' or 'ncol' cannot be specified when 'x' is a matrix")
                if ((m <- min(dim(x))) == 0L) 
                  return(vector(typeof(x), 0L))
                y <- x[1 + 0L:(m - 1L) * (dim(x)[1L] + 1)]
                if (names) {
                  nms <- dimnames(x)
                  if (is.list(nms) && !any(vapply(nms, is.null, 
                    NA)) && identical((nm <- nms[[1L]][seq_len(m)]), 
                    nms[[2L]][seq_len(m)])) 
                    names(y) <- nm
                }
                return(y)
            }
            if (is.array(x) && length(dim(x)) != 1L) 
                stop("'x' is an array, but not one-dimensional.")
            if (missing(x)) 
                n <- nrow
            else if (length(x) == 1L && nargs() == 1L) {
                n <- as.integer(x)
                x <- 1
            }
            else n <- length(x)
            if (!missing(nrow)) 
                n <- nrow
            if (missing(ncol)) 
                ncol <- n
            .Internal(diag(x, n, ncol))
        }, target = new("signature", .Data = "ANY", names = "x", 
            package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "diag"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (x = 1, nrow, ncol, names = TRUE) 
        {
            if (is.matrix(x)) {
                if (nargs() > 1L && (nargs() > 2L || any(names(match.call()) %in% 
                  c("nrow", "ncol")))) 
                  stop("'nrow' or 'ncol' cannot be specified when 'x' is a matrix")
                if ((m <- min(dim(x))) == 0L) 
                  return(vector(typeof(x), 0L))
                y <- x[1 + 0L:(m - 1L) * (dim(x)[1L] + 1)]
                if (names) {
                  nms <- dimnames(x)
                  if (is.list(nms) && !any(vapply(nms, is.null, 
                    NA)) && identical((nm <- nms[[1L]][seq_len(m)]), 
                    nms[[2L]][seq_len(m)])) 
                    names(y) <- nm
                }
                return(y)
            }
            if (is.array(x) && length(dim(x)) != 1L) 
                stop("'x' is an array, but not one-dimensional.")
            if (missing(x)) 
                n <- nrow
            else if (length(x) == 1L && nargs() == 1L) {
                n <- as.integer(x)
                x <- 1
            }
            else n <- length(x)
            if (!missing(nrow)) 
                n <- nrow
            if (missing(ncol)) 
                ncol <- n
            .Internal(diag(x, n, ncol))
        }, target = new("signature", .Data = "ANY", names = "x", 
            package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "diag"))(x, nrow, ncol, names))


.__C__dtTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(TsparseMatrix = new("SClassExtension", subClass = "dtTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("dtTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dtTMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dtTMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("dtTMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtTMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dtTMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtTMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dtTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtTMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("dtTMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtTMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "dtTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dtTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dtTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dtTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dtTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dtTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tTMatrix_validate, object), access = list(), className = structure("dtTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__lsparseMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(lMatrix = new("SClassExtension", subClass = "lsparseMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = structure("lsparseMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "lsparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lsparseMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "lsparseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), xMatrix = new("SClassExtension", subClass = "lsparseMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "lMatrix", dataPart = FALSE, distance = 2), 
        Mnumeric = new("SClassExtension", subClass = "lsparseMatrix", 
            superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "lsparseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3), replValueSp = new("SClassExtension", 
            subClass = "lsparseMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "lsparseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3)), virtual = TRUE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("lsparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(lgTMatrix = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "lsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lgTMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltTMatrix = new("SClassExtension", subClass = "ltTMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("ltTMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsTMatrix = new("SClassExtension", subClass = "lsTMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lsTMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgCMatrix = new("SClassExtension", subClass = "lgCMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lgCMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltCMatrix = new("SClassExtension", subClass = "ltCMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("ltCMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsCMatrix = new("SClassExtension", subClass = "lsCMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lsCMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgRMatrix = new("SClassExtension", subClass = "lgRMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lgRMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltRMatrix = new("SClassExtension", subClass = "ltRMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("ltRMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsRMatrix = new("SClassExtension", subClass = "lsRMatrix", 
        superClass = "lsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lsRMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__nnzero:Matrix` <- "<environment>"

.__C__xsparseVector <- new("ClassUnionRepresentation", slots = list(), contains = list(), 
    virtual = TRUE, prototype = new("dsparseVector", x = numeric(0), 
        length = 0, i = numeric(0)), validity = NULL, access = list(), 
    className = structure("xsparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(dsparseVector = new("SClassExtension", 
        subClass = "dsparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("dsparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), isparseVector = new("SClassExtension", 
        subClass = "isparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("isparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseVector = new("SClassExtension", 
        subClass = "lsparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("lsparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), zsparseVector = new("SClassExtension", 
        subClass = "zsparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("zsparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__expand:Matrix` <- "<environment>"

.bdiag <- function (lst) 
{
    stopifnot(is.list(lst), (nl <- length(lst)) >= 1)
    Tlst <- lapply(lapply(lst, as_Csp2), as, "TsparseMatrix")
    if (nl == 1) 
        return(Tlst[[1]])
    i_off <- c(0L, cumsum(vapply(Tlst, nrow, 1L)))
    j_off <- c(0L, cumsum(vapply(Tlst, ncol, 1L)))
    clss <- vapply(Tlst, class, "")
    typ <- substr(clss, 2, 2)
    knd <- substr(clss, 1, 1)
    sym <- typ == "s"
    tri <- typ == "t"
    use.n <- any(is.n <- knd == "n")
    if (use.n && !(use.n <- all(is.n))) {
        Tlst[is.n] <- lapply(Tlst[is.n], as, "lMatrix")
        knd[is.n] <- "l"
    }
    use.l <- !use.n && all(knd == "l")
    if (all(sym)) {
        uplos <- vapply(Tlst, slot, ".", "uplo")
        tLU <- table(uplos)
        if (length(tLU) == 1) {
            useU <- uplos[1] == "U"
        }
        else {
            useU <- diff(tLU) >= 0
            if (useU && (hasL <- tLU[1] > 0)) 
                Tlst[hasL] <- lapply(Tlst[hasL], t)
            else if (!useU && (hasU <- tLU[2] > 0)) 
                Tlst[hasU] <- lapply(Tlst[hasU], t)
        }
        if (use.n) {
            r <- new("nsTMatrix")
        }
        else {
            r <- new(paste0(if (use.l) 
                "l"
            else "d", "sTMatrix"))
            r@x <- unlist(lapply(Tlst, slot, "x"))
        }
        r@uplo <- if (useU) 
            "U"
        else "L"
    }
    else if (all(tri) && {
        ULs <- vapply(Tlst, slot, ".", "uplo")
        all(ULs[1L] == ULs[-1L])
    }) {
        if (use.n) {
            r <- new("ntTMatrix")
        }
        else {
            r <- new(paste0(if (use.l) 
                "l"
            else "d", "tTMatrix"))
            r@x <- unlist(lapply(Tlst, slot, "x"))
        }
        r@uplo <- ULs[1L]
    }
    else {
        if (any(sym)) 
            Tlst[sym] <- lapply(Tlst[sym], as, "generalMatrix")
        if (use.n) {
            r <- new("ngTMatrix")
        }
        else {
            r <- new(paste0(if (use.l) 
                "l"
            else "d", "gTMatrix"))
            r@x <- unlist(lapply(Tlst, slot, "x"))
        }
    }
    r@Dim <- c(i_off[nl + 1], j_off[nl + 1])
    r@i <- unlist(lapply(1:nl, function(k) Tlst[[k]]@i + i_off[k]))
    r@j <- unlist(lapply(1:nl, function(k) Tlst[[k]]@j + j_off[k]))
    r
}


sparseVector <- function (x, i, length) 
{
    newSpV(class = paste0(if (missing(x)) 
        "n"
    else .V.kind(x), "sparseVector"), x = x, i = i, length = length)
}


anyDuplicatedT <- function (x, di = dim(x)) 
anyDuplicated(.Call(m_encodeInd2, x@i, x@j, di, FALSE, FALSE))


colMeans <- new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, 
    ...) 
standardGeneric("colMeans"), generic = "colMeans", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::colMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "colMeans"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::colMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "colMeans"))(x, 
        na.rm, dims, ...))


T2graph <- function (from, need.uniq = is_not_uniqT(from), edgemode = NULL) 
{
    d <- dim(from)
    if (d[1] != d[2]) 
        stop("only square matrices can be used as incidence matrices for graphs")
    n <- d[1]
    if (n == 0) 
        return(new("graphNEL"))
    if (is.null(rn <- dimnames(from)[[1]])) 
        rn <- as.character(1:n)
    if (need.uniq) 
        from <- uniqTsparse(from)
    if (is.null(edgemode)) 
        edgemode <- if (isSymmetric(from)) {
            if (!is(from, "symmetricMatrix")) {
                from <- tril(from)
            }
            "undirected"
        }
        else {
            "directed"
        }
    ft1 <- cbind(rn[from@i + 1L], rn[from@j + 1L])
    graph::ftM2graphNEL(ft1, W = if (.hasSlot(from, "x")) 
        as.numeric(from@x), V = rn, edgemode = edgemode)
}


.__C__CHMfactor <- new("classRepresentation", slots = list(colcount = structure("integer", package = "methods"), 
    perm = structure("integer", package = "methods"), type = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods")), contains = list(
    CholeskyFactorization = new("SClassExtension", subClass = "CHMfactor", 
        superClass = "CholeskyFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), MatrixFactorization = new("SClassExtension", 
        subClass = "CHMfactor", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 2)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(CHMfactor_validate, object), access = list(), className = structure("CHMfactor", package = "Matrix"), 
    package = "Matrix", subclasses = list(CHMsuper = new("SClassExtension", 
        subClass = "CHMsuper", superClass = "CHMfactor", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsuper"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMsimpl = new("SClassExtension", subClass = "CHMsimpl", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsimpl"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dCHMsuper = new("SClassExtension", subClass = "dCHMsuper", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsuper"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dCHMsuper"), simple = TRUE, by = "CHMsuper", dataPart = FALSE, 
        distance = 2), nCHMsuper = new("SClassExtension", subClass = "nCHMsuper", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsuper"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nCHMsuper"), simple = TRUE, by = "CHMsuper", dataPart = FALSE, 
        distance = 2), dCHMsimpl = new("SClassExtension", subClass = "dCHMsimpl", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsimpl"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dCHMsimpl"), simple = TRUE, by = "CHMsimpl", dataPart = FALSE, 
        distance = 2), nCHMsimpl = new("SClassExtension", subClass = "nCHMsimpl", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsimpl"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nCHMsimpl"), simple = TRUE, by = "CHMsimpl", dataPart = FALSE, 
        distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE)


chol2inv <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("chol2inv"), generic = "chol2inv", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    base::chol2inv(x, ...), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "chol2inv"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    base::chol2inv(x, ...), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "chol2inv"))(x, 
        ...))


.sparseDiagonal <- function (n, x = 1, uplo = "U", shape = if (missing(cols)) "t" else "g", 
    unitri, kind, cols = if (n) 0:(n - 1L) else integer(0)) 
{
    n <- if (missing(n)) 
        length(x)
    else {
        stopifnot(length(n) == 1, n == as.integer(n), n >= 0)
        as.integer(n)
    }
    if (!(mcols <- missing(cols))) 
        stopifnot(0 <= (cols <- as.integer(cols)), cols < n)
    m <- length(cols)
    if (missing(kind)) 
        kind <- if (is.double(x)) 
            "d"
        else if (is.logical(x)) 
            "l"
        else {
            storage.mode(x) <- "double"
            "d"
        }
    else stopifnot(any(kind == c("d", "l", "n")))
    stopifnot(is.character(shape), nchar(shape) == 1, any(shape == 
        c("t", "s", "g")))
    if ((missing(unitri) || unitri) && shape == "t" && (mcols || 
        cols == 0:(n - 1L)) && ((any(kind == c("l", "n")) && 
        allTrue(x)) || (kind == "d" && allTrue(x == 1)))) {
        new(paste0(kind, "tCMatrix"), Dim = c(n, n), uplo = uplo, 
            diag = "U", p = rep.int(0L, n + 1L))
    }
    else if (kind == "n") {
        if (shape == "g") 
            new("ngCMatrix", Dim = c(n, m), i = cols, p = 0:m)
        else new(paste0("n", shape, "CMatrix"), Dim = c(n, m), 
            uplo = uplo, i = cols, p = 0:m)
    }
    else {
        if ((lx <- length(x)) == 1) 
            x <- rep.int(x, m)
        else if (lx != m) 
            stop("length(x) must be either 1 or #{cols}")
        if (shape == "g") 
            new(paste0(kind, "gCMatrix"), Dim = c(n, m), x = x, 
                i = cols, p = 0:m)
        else new(paste0(kind, shape, "CMatrix"), Dim = c(n, m), 
            uplo = uplo, x = x, i = cols, p = 0:m)
    }
}


unpack <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("unpack"), generic = "unpack", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x, ...) 
    stop("invalid call in method dispatch to 'unpack' (no default method)", 
        domain = NA))(x, ...))


.__C__Matrix <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    mMatrix = new("SClassExtension", subClass = "Matrix", superClass = "mMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "mMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "mMatrix", dQuote("Matrix"), "mMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Mnumeric = new("SClassExtension", subClass = "Matrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Mnumeric")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Mnumeric", dQuote("Matrix"), "Mnumeric", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), replValueSp = new("SClassExtension", subClass = "Matrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValueSp")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValueSp", dQuote("Matrix"), "replValueSp", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    {
        if (!isTRUE(r <- .Call(Dim_validate, object, "Matrix"))) 
            r
        else .Call(dimNames_validate, object)
    }, access = list(), className = structure("Matrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(compMatrix = new("SClassExtension", 
        subClass = "compMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = "triangularMatrix", superClass = "Matrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = "dMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), iMatrix = new("SClassExtension", subClass = "iMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("iMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = "lMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = "nMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), zMatrix = new("SClassExtension", subClass = "zMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("zMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), denseMatrix = new("SClassExtension", subClass = "denseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = "sparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = "generalMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "generalMatrix"), simple = TRUE, by = "compMatrix", 
        dataPart = FALSE, distance = 2), symmetricMatrix = new("SClassExtension", 
        subClass = "symmetricMatrix", superClass = "Matrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "symmetricMatrix"), simple = TRUE, by = "compMatrix", 
        dataPart = FALSE, distance = 2), ddenseMatrix = new("SClassExtension", 
        subClass = "ddenseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 2), ldenseMatrix = new("SClassExtension", 
        subClass = "ldenseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 2), ndenseMatrix = new("SClassExtension", 
        subClass = "ndenseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), simple = TRUE, by = "nMatrix", dataPart = FALSE, 
        distance = 2), ddenseMatrix = new("SClassExtension", 
        subClass = "ddenseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ddenseMatrix"), simple = TRUE, by = "denseMatrix", 
        dataPart = FALSE, distance = 2), ldenseMatrix = new("SClassExtension", 
        subClass = "ldenseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ldenseMatrix"), simple = TRUE, by = "denseMatrix", 
        dataPart = FALSE, distance = 2), ndenseMatrix = new("SClassExtension", 
        subClass = "ndenseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("denseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ndenseMatrix"), simple = TRUE, by = "denseMatrix", 
        dataPart = FALSE, distance = 2), diagonalMatrix = new("SClassExtension", 
        subClass = "diagonalMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), TsparseMatrix = new("SClassExtension", 
        subClass = "TsparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), CsparseMatrix = new("SClassExtension", 
        subClass = "CsparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), RsparseMatrix = new("SClassExtension", 
        subClass = "RsparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), dsparseMatrix = new("SClassExtension", 
        subClass = "dsparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dsparseMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 2), lsparseMatrix = new("SClassExtension", 
        subClass = "lsparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lsparseMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 2), nsparseMatrix = new("SClassExtension", 
        subClass = "nsparseMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nsparseMatrix"), simple = TRUE, by = "nMatrix", dataPart = FALSE, 
        distance = 2), dgeMatrix = new("SClassExtension", subClass = "dgeMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dgeMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), dtrMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtrMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), dtpMatrix = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtpMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), dsyMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dsyMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), dspMatrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dspMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), dpoMatrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 4), dppMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 4), lgeMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lgeMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), ltrMatrix = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltrMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), ltpMatrix = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltpMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), lsyMatrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lsyMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), lspMatrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lspMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), ngeMatrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ngeMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), ntrMatrix = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntrMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), ntpMatrix = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "ntpMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), nsyMatrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nsyMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), nspMatrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), "nspMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 3), ddiMatrix = new("SClassExtension", 
        subClass = "ddiMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ddiMatrix"), simple = TRUE, by = "diagonalMatrix", 
        dataPart = FALSE, distance = 3), ldiMatrix = new("SClassExtension", 
        subClass = "ldiMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ldiMatrix"), simple = TRUE, by = "diagonalMatrix", 
        dataPart = FALSE, distance = 3), corMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 5), dgTMatrix = new("SClassExtension", subClass = "dgTMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dgTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), dtTMatrix = new("SClassExtension", 
        subClass = "dtTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dtTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), dsTMatrix = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), dgCMatrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), dtCMatrix = new("SClassExtension", 
        subClass = "dtCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dtCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), dsCMatrix = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), dgRMatrix = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dgRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), dtRMatrix = new("SClassExtension", 
        subClass = "dtRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dtRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), dsRMatrix = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), lgTMatrix = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lgTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), ltTMatrix = new("SClassExtension", 
        subClass = "ltTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ltTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), lsTMatrix = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "lsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), lgCMatrix = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), ltCMatrix = new("SClassExtension", 
        subClass = "ltCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ltCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), lsCMatrix = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), lgRMatrix = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lgRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), ltRMatrix = new("SClassExtension", 
        subClass = "ltRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ltRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), lsRMatrix = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), ngTMatrix = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ngTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), ntTMatrix = new("SClassExtension", 
        subClass = "ntTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ntTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), nsTMatrix = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "nsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), ngCMatrix = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ngCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), ntCMatrix = new("SClassExtension", 
        subClass = "ntCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ntCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), nsCMatrix = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "nsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), ngRMatrix = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ngRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), ntRMatrix = new("SClassExtension", 
        subClass = "ntRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ntRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), nsRMatrix = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "nsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), indMatrix = new("SClassExtension", 
        subClass = "indMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "indMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), pMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("indMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 4), Cholesky = new("SClassExtension", 
        subClass = "Cholesky", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), pCholesky = new("SClassExtension", 
        subClass = "pCholesky", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtrMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__anyNA:base` <- "<environment>"

`diag<-` <- new("standardGeneric", .Data = function (x, value) 
standardGeneric("diag<-"), generic = "diag<-", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "value"), default = new("derivedDefaultMethod", .Data = function (x, 
        value) 
    {
        dx <- dim(x)
        if (length(dx) != 2L) 
            stop("only matrix diagonals can be replaced")
        len.i <- min(dx)
        len.v <- length(value)
        if (len.v != 1L && len.v != len.i) 
            stop("replacement diagonal has wrong length")
        if (len.i) {
            i <- seq_len(len.i)
            x[cbind(i, i)] <- value
        }
        x
    }, target = new("signature", .Data = "ANY", names = "x", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), generic = "diag<-"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        value) 
    {
        dx <- dim(x)
        if (length(dx) != 2L) 
            stop("only matrix diagonals can be replaced")
        len.i <- min(dx)
        len.v <- length(value)
        if (len.v != 1L && len.v != len.i) 
            stop("replacement diagonal has wrong length")
        if (len.i) {
            i <- seq_len(len.i)
            x[cbind(i, i)] <- value
        }
        x
    }, target = new("signature", .Data = "ANY", names = "x", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), generic = "diag<-"))(x, 
        value))


.__C__corMatrix <- new("classRepresentation", slots = list(sd = structure("numeric", package = "methods"), 
    x = structure("numeric", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    dpoMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "dpoMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            value <- new("dpoMatrix")
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(value, what) <- slot(from, what)
            value
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsyMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "dsyMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                class(from) <- "dsyMatrix"
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "dsyMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 2), ddenseMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 3), symmetricMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "symmetricMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 3), dMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 4), denseMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 4), compMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 4), Matrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 5), mMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dpoMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(value, what) <- slot(from, 
                    what)
                  value
                }
                {
                  from <- {
                    class(from) <- "dsyMatrix"
                    from
                  }
                  from
                }
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 6), 
    xMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dpoMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(value, what) <- slot(from, 
                    what)
                  value
                }
                {
                  from <- {
                    class(from) <- "dsyMatrix"
                    from
                  }
                  from
                }
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dMatrix", dataPart = FALSE, distance = 5), 
    Mnumeric = new("SClassExtension", subClass = "corMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dpoMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(value, what) <- slot(from, 
                    what)
                  value
                }
                {
                  from <- {
                    class(from) <- "dsyMatrix"
                    from
                  }
                  from
                }
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 6), 
    replValueSp = new("SClassExtension", subClass = "corMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dpoMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(value, what) <- slot(from, 
                    what)
                  value
                }
                {
                  from <- {
                    class(from) <- "dsyMatrix"
                    from
                  }
                  from
                }
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 6)), 
    virtual = FALSE, prototype = S4_object(), validity = function (object) 
    {
        n <- object@Dim[2]
        if (length(sd <- object@sd) != n) 
            return("'sd' slot must be of length 'dim(.)[1]'")
        if (any(!is.finite(sd))) 
            return("'sd' slot has non-finite entries")
        if (any(sd < 0)) 
            return("'sd' slot has negative entries")
        TRUE
    }, access = list(), className = structure("corMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__dsTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(TsparseMatrix = new("SClassExtension", subClass = "dsTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("dsTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dsTMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dsTMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("dsTMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsTMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dsTMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsTMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dsTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsTMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dsTMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsTMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "dsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tTMatrix_validate, object), access = list(), className = structure("dsTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__lgCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    CsparseMatrix = new("SClassExtension", subClass = "lgCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("lgCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("lgCMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lgCMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("lgCMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgCMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lCsparseMatrix = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "lCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lCsparseMatrix", dQuote("lgCMatrix"), "lCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("lgCMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("lgCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgCMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lgCMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgCMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), xMatrix = new("SClassExtension", 
        subClass = structure("lgCMatrix", package = "Matrix"), 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("lMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lsparseMatrix"), "lgCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lgCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lgCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xCMatrix_validate, object), access = list(), className = structure("lgCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__as.vector:base` <- "<environment>"

`.__T__rowMeans:base` <- "<environment>"

`.__T__as.matrix:base` <- "<environment>"

.__C__LU <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods")), 
    contains = list(MatrixFactorization = new("SClassExtension", 
        subClass = "LU", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("LU"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("LU", package = "Matrix"), 
    package = "Matrix", subclasses = list(denseLU = new("SClassExtension", 
        subClass = "denseLU", superClass = "LU", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "LU")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "LU", dQuote("denseLU"), "LU", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseLU = new("SClassExtension", subClass = "sparseLU", 
        superClass = "LU", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "LU")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "LU", dQuote("sparseLU"), "LU", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__^:base` <- "<environment>"

`.__T__rowSums:base` <- "<environment>"

`.__T__as.numeric:base` <- "<environment>"

`.__T__length:base` <- "<environment>"

.__C__CholeskyFactorization <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods")), 
    contains = list(MatrixFactorization = new("SClassExtension", 
        subClass = "CholeskyFactorization", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("CholeskyFactorization", package = "Matrix"), 
    package = "Matrix", subclasses = list(Cholesky = new("SClassExtension", 
        subClass = "Cholesky", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("Cholesky"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), pCholesky = new("SClassExtension", subClass = "pCholesky", 
        superClass = "CholeskyFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("pCholesky"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMfactor = new("SClassExtension", subClass = "CHMfactor", 
        superClass = "CholeskyFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMsuper = new("SClassExtension", subClass = "CHMsuper", 
        superClass = "CholeskyFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), simple = TRUE, by = "CHMfactor", dataPart = FALSE, 
        distance = 2), CHMsimpl = new("SClassExtension", subClass = "CHMsimpl", 
        superClass = "CholeskyFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), simple = TRUE, by = "CHMfactor", dataPart = FALSE, 
        distance = 2), dCHMsuper = new("SClassExtension", subClass = "dCHMsuper", 
        superClass = "CholeskyFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), "dCHMsuper"), simple = TRUE, by = "CHMsuper", 
        dataPart = FALSE, distance = 3), nCHMsuper = new("SClassExtension", 
        subClass = "nCHMsuper", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), "nCHMsuper"), simple = TRUE, by = "CHMsuper", 
        dataPart = FALSE, distance = 3), dCHMsimpl = new("SClassExtension", 
        subClass = "dCHMsimpl", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), "dCHMsimpl"), simple = TRUE, by = "CHMsimpl", 
        dataPart = FALSE, distance = 3), nCHMsimpl = new("SClassExtension", 
        subClass = "nCHMsimpl", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), "nCHMsimpl"), simple = TRUE, by = "CHMsimpl", 
        dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


is.null.DN <- function (dn) 
{
    is.null(dn) || {
        if (!is.null(names(dn))) 
            names(dn) <- NULL
        ch0 <- character(0)
        identical(dn, list(NULL, NULL)) || identical(dn, list(ch0, 
            NULL)) || identical(dn, list(NULL, ch0)) || identical(dn, 
            list(ch0, ch0))
    }
}


norm <- new("standardGeneric", .Data = function (x, type, ...) 
standardGeneric("norm"), generic = "norm", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "type"), default = new("derivedDefaultMethod", .Data = function (x, 
        type, ...) 
    base::norm(x, type, ...), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "norm"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        type, ...) 
    base::norm(x, type, ...), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "norm"))(x, 
        type, ...))


Arith <- methods::Arith # re-exported from methods package

.__C__dtCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(CsparseMatrix = new("SClassExtension", subClass = "dtCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("dtCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dtCMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtCMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dCsparseMatrix = new("SClassExtension", 
        subClass = "dtCMatrix", superClass = "dCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dCsparseMatrix", dQuote("dtCMatrix"), "dCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtCMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtCMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), xMatrix = new("SClassExtension", 
        subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("dMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dsparseMatrix"), "dtCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = structure("dtCMatrix", package = "Matrix"), 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtCMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 3), Mnumeric = new("SClassExtension", 
        subClass = "dtCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dtCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dtCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dtCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tCMatrix_validate, object), access = list(), className = structure("dtCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__qr.coef:base` <- "<environment>"

t <- new("standardGeneric", .Data = function (x) 
standardGeneric("t"), generic = "t", package = "base", group = list(), 
    valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", 
        .Data = function (x) 
        UseMethod("t"), target = new("signature", .Data = "ANY", 
            names = "x", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "t"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (x) 
        UseMethod("t"), target = new("signature", .Data = "ANY", 
            names = "x", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "t"))(x))


`.__T__Cholesky:Matrix` <- "<environment>"

`.__T__solve:base` <- "<environment>"

`.__T__as.array:base` <- "<environment>"

.__C__dCHMsimpl <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    p = structure("integer", package = "methods"), i = structure("integer", package = "methods"), 
    nz = structure("integer", package = "methods"), nxt = structure("integer", package = "methods"), 
    prv = structure("integer", package = "methods"), colcount = structure("integer", package = "methods"), 
    perm = structure("integer", package = "methods"), type = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods")), contains = list(
    CHMsimpl = new("SClassExtension", subClass = "dCHMsimpl", 
        superClass = "CHMsimpl", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsimpl")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsimpl", dQuote("dCHMsimpl"), "CHMsimpl", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMfactor = new("SClassExtension", subClass = "dCHMsimpl", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsimpl"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dCHMsimpl"), simple = TRUE, by = "CHMsimpl", dataPart = FALSE, 
        distance = 2), CholeskyFactorization = new("SClassExtension", 
        subClass = "dCHMsimpl", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), "dCHMsimpl"), simple = TRUE, by = "CHMsimpl", 
        dataPart = FALSE, distance = 3), MatrixFactorization = new("SClassExtension", 
        subClass = "dCHMsimpl", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as(as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), "CHMsimpl"), "dCHMsimpl"), simple = TRUE, 
        by = "CHMsimpl", dataPart = FALSE, distance = 4)), virtual = FALSE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("dCHMsimpl", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__qr.resid:base` <- "<environment>"

spMatrix <- function (nrow, ncol, i = integer(), j = integer(), x = numeric()) 
{
    dim <- c(as.integer(nrow), as.integer(ncol))
    kind <- .M.kind(x)
    new(paste0(kind, "gTMatrix"), Dim = dim, x = if (kind == 
        "d") 
        as.double(x)
    else x, i = as.integer(i - 1L), j = as.integer(j - 1L))
}


kronecker <- methods::kronecker # re-exported from methods package

invPerm <- function (p, zero.p = FALSE, zero.res = FALSE) 
.Call(inv_permutation, p, zero.p, zero.res)


.__C__ddenseMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(dMatrix = new("SClassExtension", subClass = "ddenseMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), denseMatrix = new("SClassExtension", subClass = structure("ddenseMatrix", package = "Matrix"), 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "ddenseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "ddenseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), xMatrix = new("SClassExtension", subClass = "ddenseMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "dMatrix", dataPart = FALSE, distance = 2), 
        Mnumeric = new("SClassExtension", subClass = "ddenseMatrix", 
            superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "ddenseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3), replValueSp = new("SClassExtension", 
            subClass = "ddenseMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "ddenseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3)), virtual = TRUE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("ddenseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dgeMatrix = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dgeMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtrMatrix = new("SClassExtension", subClass = "dtrMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dtrMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtpMatrix = new("SClassExtension", subClass = "dtpMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dtpMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsyMatrix = new("SClassExtension", subClass = "dsyMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dsyMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dspMatrix = new("SClassExtension", subClass = "dspMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dspMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dpoMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 2), dppMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 2), corMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 3), Cholesky = new("SClassExtension", subClass = "Cholesky", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 2), pCholesky = new("SClassExtension", subClass = "pCholesky", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 2), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 2), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__which:base` <- "<environment>"

.__C__symmetricMatrix <- new("classRepresentation", slots = list(uplo = structure("character", package = "methods"), 
    factors = structure("list", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    compMatrix = new("SClassExtension", subClass = "symmetricMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "symmetricMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "symmetricMatrix"), simple = TRUE, by = "compMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "symmetricMatrix", superClass = "mMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "symmetricMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 3), Mnumeric = new("SClassExtension", 
        subClass = "symmetricMatrix", superClass = "Mnumeric", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "symmetricMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 3), replValueSp = new("SClassExtension", 
        subClass = "symmetricMatrix", superClass = "replValueSp", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "symmetricMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(symmetricMatrix_validate, object), access = list(), 
    className = structure("symmetricMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dsyMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "symmetricMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsyMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dspMatrix = new("SClassExtension", subClass = "dspMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dspMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsyMatrix = new("SClassExtension", subClass = "lsyMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsyMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lspMatrix = new("SClassExtension", subClass = "lspMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lspMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsyMatrix = new("SClassExtension", subClass = "nsyMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsyMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nspMatrix = new("SClassExtension", subClass = "nspMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nspMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsTMatrix = new("SClassExtension", subClass = "dsTMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsTMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsCMatrix = new("SClassExtension", subClass = "dsCMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsCMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsRMatrix = new("SClassExtension", subClass = "dsRMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsRMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsTMatrix = new("SClassExtension", subClass = "lsTMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsTMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsCMatrix = new("SClassExtension", subClass = "lsCMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsCMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsRMatrix = new("SClassExtension", subClass = "lsRMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsRMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsTMatrix = new("SClassExtension", subClass = "nsTMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsTMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsCMatrix = new("SClassExtension", subClass = "nsCMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsCMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsRMatrix = new("SClassExtension", subClass = "nsRMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsRMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dpoMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "symmetricMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 2), dppMatrix = new("SClassExtension", subClass = "dppMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "symmetricMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dspMatrix", dataPart = FALSE, 
        distance = 2), corMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "symmetricMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  value <- new("dpoMatrix")
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(value, what) <- slot(from, 
                    what)
                  value
                }
                {
                  class(from) <- "dsyMatrix"
                  from
                }
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "symmetricMatrix") <- value
            value <- .value
            {
                .value <- as(from, "dpoMatrix", TRUE)
                as(.value, "dsyMatrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "factors")) slot(from, what) <- slot(value, 
                    what)
                  from
                }
            }
        }, simple = TRUE, by = "dsyMatrix", dataPart = FALSE, 
        distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE)


Compare <- methods::Compare # re-exported from methods package

graph2T <- function (from, use.weights = graph.has.weights(from) && graph.non.1.weights(from)) 
{
    nd <- graph::nodes(from)
    dnms <- list(nd, nd)
    dm <- rep.int(length(nd), 2)
    edge2i <- function(e) {
        rep.int(0:(dm[1] - 1L), lengths(e))
    }
    if (use.weights) {
        eWts <- graph::edgeWeights(from)
        names(eWts) <- NULL
        i <- edge2i(eWts)
        To <- unlist(lapply(eWts, names))
        j <- as.integer(match(To, nd)) - 1L
        new("dgTMatrix", i = i, j = j, x = unlist(eWts), Dim = dm, 
            Dimnames = dnms)
    }
    else {
        edges <- lapply(from@edgeL[nd], "[[", "edges")
        symm <- graph::edgemode(from) == "undirected"
        if (symm) 
            edges <- lapply(seq_along(edges), function(i) {
                e <- edges[[i]]
                e[e >= i]
            })
        i <- edge2i(edges)
        j <- as.integer(unlist(edges)) - 1L
        new(if (symm) 
            "nsTMatrix"
        else "ngTMatrix", i = i, j = j, Dim = dm, Dimnames = dnms)
    }
}


`.__T__crossprod:base` <- "<environment>"

rcond <- new("standardGeneric", .Data = function (x, norm, ...) 
standardGeneric("rcond"), generic = "rcond", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "norm"), default = new("derivedDefaultMethod", .Data = function (x, 
        norm, ...) 
    base::rcond(x, norm, ...), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "rcond"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        norm, ...) 
    base::rcond(x, norm, ...), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "rcond"))(x, 
        norm, ...))


.__C__nMatrix <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    Matrix = new("SClassExtension", subClass = "nMatrix", superClass = "Matrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "nMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    Mnumeric = new("SClassExtension", subClass = "nMatrix", superClass = "Mnumeric", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    replValueSp = new("SClassExtension", subClass = "nMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2)), 
    virtual = TRUE, prototype = S4_object(), validity = NULL, 
    access = list(), className = structure("nMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ndenseMatrix = new("SClassExtension", 
        subClass = "ndenseMatrix", superClass = "nMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = "nsparseMatrix", superClass = "nMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngeMatrix = new("SClassExtension", subClass = "ngeMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngeMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), ntrMatrix = new("SClassExtension", 
        subClass = "ntrMatrix", superClass = "nMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntrMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), ntpMatrix = new("SClassExtension", 
        subClass = "ntpMatrix", superClass = "nMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntpMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), nsyMatrix = new("SClassExtension", 
        subClass = "nsyMatrix", superClass = "nMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsyMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2), nspMatrix = new("SClassExtension", 
        subClass = "nspMatrix", superClass = "nMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nspMatrix"), simple = TRUE, by = "ndenseMatrix", 
        dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__chol:base` <- "<environment>"

.__C__nsparseVector <- new("classRepresentation", slots = list(length = structure("numeric", package = "methods"), 
    i = structure("numeric", package = "methods")), contains = list(
    sparseVector = new("SClassExtension", subClass = "nsparseVector", 
        superClass = "sparseVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("nsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), replValueSp = new("SClassExtension", subClass = "nsparseVector", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("nsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "sparseVector", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("nsparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


abIseq <- function (from = 1, to = 1, by = ((to - from)/(length.out - 1)), 
    length.out = NULL, along.with = NULL) 
{
    if ((One <- nargs() == 1L) && !missing(from)) {
        lf <- length(from)
        return(if (mode(from) == "numeric" && lf == 1L) abIseq1(1L, 
            from) else if (lf) abIseq1(1L, lf) else new("abIndex"))
    }
    if (!missing(along.with)) {
        length.out <- length(along.with)
        if (One) 
            return(if (length.out) abIseq1(1L, length.out) else new("abIndex"))
    }
    else if (!missing(length.out)) 
        length.out <- ceiling(length.out)
    if (is.null(length.out)) 
        if (missing(by)) 
            abIseq1(from, to)
        else {
            del <- to - from
            if (del == 0 && to == 0) 
                return(as(to, "abIndex"))
            n <- del/by
            if (!(length(n) && is.finite(n))) {
                if (length(by) && by == 0 && length(del) && del == 
                  0) 
                  return(as(from, "abIndex"))
                stop("invalid (to - from)/by in seq(.)")
            }
            if (n < 0L) 
                stop("wrong sign in 'by' argument")
            if (n > .Machine$integer.max) 
                stop("'by' argument is much too small")
            dd <- abs(del)/max(abs(to), abs(from))
            if (dd < 100 * .Machine$double.eps) 
                return(from)
            n <- as.integer(n + 1e-07)
            x <- from + abIseq1(0L, n) * by
            if (by > 0) 
                pmin(x, to)
            else pmax(x, to)
        }
    else if (!is.finite(length.out) || length.out < 0L) 
        stop("length must be non-negative number")
    else if (length.out == 0L) 
        new("abIndex")
    else if (One) 
        abIseq1(1L, length.out)
    else if (missing(by)) {
        if (missing(to)) 
            to <- from + length.out - 1L
        if (missing(from)) 
            from <- to - length.out + 1L
        if (length.out > 2L) 
            if (from == to) 
                rep2abI(from, length.out)
            else c(as(from, "abIndex"), from + abIseq1(1L, length.out - 
                2L) * by, to)
        else as(c(from, to)[seq_len(length.out)], "abIndex")
    }
    else if (missing(to)) 
        from + abIseq1(0L, length.out - 1L) * by
    else if (missing(from)) 
        to - abIseq1(length.out - 1L, 0L) * by
    else stop("too many arguments")
}


as.matrix <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("as.matrix"), generic = "as.matrix", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("as.matrix"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "as.matrix"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("as.matrix"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "as.matrix"))(x, 
        ...))


lu <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("lu"), generic = "lu", package = "Matrix", group = list(), 
    valueClass = character(0), signature = "x", default = NULL, 
    skeleton = (function (x, ...) 
    stop("invalid call in method dispatch to 'lu' (no default method)", 
        domain = NA))(x, ...))


`.__T__/:base` <- "<environment>"

`.__T__tail:utils` <- "<environment>"

`.__T__mean:base` <- "<environment>"

`.__T__isSymmetric:base` <- "<environment>"

symmpart <- new("standardGeneric", .Data = function (x) 
standardGeneric("symmpart"), generic = "symmpart", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x) 
    stop("invalid call in method dispatch to 'symmpart' (no default method)", 
        domain = NA))(x))


`%&%` <- new("standardGeneric", .Data = function (x, y) 
standardGeneric("%&%"), generic = "%&%", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("x", 
    "y"), default = NULL, skeleton = (function (x, y) 
    stop("invalid call in method dispatch to '%&%' (no default method)", 
        domain = NA))(x, y))


`.__T__all.equal:base` <- "<environment>"

.diag2sT <- function (from, uplo = "U", kind = .M.kind(from)) 
{
    n <- from@Dim[1]
    i <- seq_len(n) - 1L
    new(paste0(kind, "sTMatrix"), Dim = from@Dim, Dimnames = from@Dimnames, 
        i = i, j = i, uplo = uplo, x = if (from@diag == "N") 
            from@x
        else rep.int(switch(kind, d = 1, l = , n = TRUE, stop(gettextf("%s kind not yet implemented", 
            sQuote(kind)), domain = NA)), n))
}


bdiag <- function (...) 
{
    if ((nA <- nargs()) == 0) 
        return(new("dgCMatrix"))
    if (nA == 1 && !is.list(...)) 
        return(as(..., "CsparseMatrix"))
    alis <- if (nA == 1 && is.list(..1)) 
        ..1
    else list(...)
    if (length(alis) == 1) 
        return(as(alis[[1]], "CsparseMatrix"))
    as(.bdiag(alis), "CsparseMatrix")
}


updown <- new("standardGeneric", .Data = function (update, C, L) 
standardGeneric("updown"), generic = "updown", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("update", 
    "C", "L"), default = NULL, skeleton = (function (update, 
        C, L) 
    stop("invalid call in method dispatch to 'updown' (no default method)", 
        domain = NA))(update, C, L))


Math2 <- methods::Math2 # re-exported from methods package

`.__T__%*%:base` <- "<environment>"

.__C__Schur <- new("classRepresentation", slots = list(T = structure("Matrix", package = "Matrix"), 
    Q = structure("Matrix", package = "Matrix"), EValues = structure("number", package = "Matrix"), 
    Dim = structure("integer", package = "methods")), contains = list(
    MatrixFactorization = new("SClassExtension", subClass = "Schur", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("Schur"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        dim <- object@Dim
        if ((n <- dim[1]) != dim[2]) 
            "'Dim' slot is not (n,n)"
        else if (any(dim(object@T) != n)) 
            "'dim(T)' is incorrect"
        else if (any(dim(object@Q) != n)) 
            "'dim(Q)' is incorrect"
        else if (length(object@EValues) != n) 
            "'EValues' is not of correct length"
        else TRUE
    }, access = list(), className = structure("Schur", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__symmpart:Matrix` <- "<environment>"

.__C__lgRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    RsparseMatrix = new("SClassExtension", subClass = "lgRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("lgRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("lgRMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lgRMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("lgRMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgRMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("lgRMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgRMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("lgRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgRMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lgRMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgRMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lgRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lgRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lgRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lgRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xRMatrix_validate, object), access = list(), className = structure("lgRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


condest <- function (A, t = min(n, 5), normA = norm(A, "1"), silent = FALSE, 
    quiet = TRUE) 
{
    if (length(d <- dim(A)) != 2 || (n <- d[1]) != d[2]) 
        stop("'A' must be a square matrix")
    luA <- lu(A)
    i.n <- seq_len(n)
    isSparse <- is(A, "sparseMatrix")
    if (isSparse) {
        q. <- q.i <- luA@q + 1L
        q.i[q.i] <- i.n
        p. <- p.i <- luA@p + 1L
        p.i[p.i] <- i.n
        Ut <- t(luA@U)
        Lt <- t(luA@L)
        f.solve <- function(x) solve(luA@U, solve(luA@L, x[p., 
            ]))[q.i, ]
        f.solve_t <- function(x) solve(Lt, solve(Ut, x[q., ]))[p.i, 
            ]
    }
    else {
        e.A <- expand(luA)
        p. <- p.i <- luA@perm
        p.i[p.i] <- i.n
        Ut <- t(e.A$U)
        Lt <- t(e.A$L)
        f.solve <- function(x) solve(e.A$U, solve(e.A$L, x[p., 
            ]))
        f.solve_t <- function(x) solve(Lt, solve(Ut, x))[p.i, 
            ]
    }
    n1.res <- onenormest(A.x = f.solve, At.x = f.solve_t, t = t, 
        n = n, quiet = quiet, silent = silent)
    w <- n1.res[["w"]]
    list(est = normA * n1.res[["est"]], v = w/sum(abs(w)))
}


`.__T__rbind2:methods` <- "<environment>"

.dense2sy <- function (from, ...) 
{
    if (isSymmetric(from, ...)) 
        .Call(dense_to_symmetric, from, "U", FALSE)
    else stop("not a symmetric matrix; consider forceSymmetric() or symmpart()")
}


.T2Cmat <- function (from, isTri = is(from, "triangularMatrix")) 
.Call(Tsparse_to_Csparse, from, isTri)


cBind <- function (..., deparse.level = 1) 
{
    if (is.null(wrn <- get0("warned.cBind", .MatrixEnv)) || isTRUE(getOption("Matrix.warn")) || 
        isTRUE(getOption("Matrix.verbose"))) {
        if (is.null(wrn)) 
            assign("warned.cBind", TRUE, envir = .MatrixEnv)
        .Deprecated(msg = "'cBind' is deprecated.\n Since R version 3.2.0, base's cbind() should work fine with S4 objects")
    }
    base::cbind(..., deparse.level = deparse.level)
}


.__C__pCholesky <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(dtpMatrix = new("SClassExtension", subClass = "pCholesky", 
        superClass = "dtpMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "dtpMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CholeskyFactorization = new("SClassExtension", 
        subClass = structure("pCholesky", package = "Matrix"), 
        superClass = structure("CholeskyFactorization", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("pCholesky"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddenseMatrix = new("SClassExtension", 
        subClass = "pCholesky", superClass = "ddenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "ddenseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 2), triangularMatrix = new("SClassExtension", 
        subClass = "pCholesky", superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "triangularMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), MatrixFactorization = new("SClassExtension", 
        subClass = structure("pCholesky", package = "Matrix"), 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "pCholesky"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 2), dMatrix = new("SClassExtension", 
        subClass = "pCholesky", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3), denseMatrix = new("SClassExtension", subClass = "pCholesky", 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "denseMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3), Matrix = new("SClassExtension", subClass = "pCholesky", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dtpMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "pCholesky", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "dtpMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 4), 
        xMatrix = new("SClassExtension", subClass = "pCholesky", 
            superClass = "xMatrix", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dtpMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dtpMatrix", TRUE)
                as(.value, "dMatrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(from, what) <- slot(value, what)
                  from
                }
            }, simple = TRUE, by = "dMatrix", dataPart = FALSE, 
            distance = 4), Mnumeric = new("SClassExtension", 
            subClass = "pCholesky", superClass = "Mnumeric", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dtpMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dtpMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(from, what) <- slot(value, what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 4), replValueSp = new("SClassExtension", 
            subClass = "pCholesky", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                from <- {
                  from <- {
                    class(from) <- "dtpMatrix"
                    from
                  }
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "dtpMatrix", TRUE)
                as(.value, "Matrix") <- value
                value <- .value
                {
                  for (what in c("x", "Dim", "Dimnames", "uplo", 
                  "diag")) slot(from, what) <- slot(value, what)
                  from
                }
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("pCholesky", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.validateCsparse <- function (x, sort.if.needed = FALSE) 
.Call(Csparse_validate2, x, sort.if.needed)


`.__T__colMeans:base` <- "<environment>"

.__C__replValue <- new("ClassUnionRepresentation", slots = list(), contains = list(
    replValueSp = new("SClassExtension", subClass = "replValue", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValueSp")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValueSp", dQuote("replValue"), "replValueSp", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), virtual = TRUE, prototype = numeric(0), 
    validity = NULL, access = list(), className = structure("replValue", package = "Matrix"), 
    package = "Matrix", subclasses = list(numeric = new("SClassExtension", 
        subClass = "numeric", superClass = "replValue", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValue")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValue", dQuote("numeric"), "replValue", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), logical = new("SClassExtension", subClass = "logical", 
        superClass = "replValue", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValue")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValue", dQuote("logical"), "replValue", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), complex = new("SClassExtension", subClass = "complex", 
        superClass = "replValue", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValue")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValue", dQuote("complex"), "replValue", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), raw = new("SClassExtension", subClass = "raw", 
        superClass = "replValue", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "replValue")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "replValue", dQuote("raw"), "replValue", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), integer = new("SClassExtension", subClass = "integer", 
        superClass = "replValue", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "numeric"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "numeric", TRUE)
            as(.value, "replValue") <- value
            value <- .value
            {
                class(value) <- "integer"
                value
            }
        }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2), 
        double = new("SClassExtension", subClass = "double", 
            superClass = "replValue", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  class(from) <- "numeric"
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "replValue") <- value
                value <- .value
                {
                  class(value) <- "double"
                  value
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 2), factor = new("SClassExtension", subClass = "factor", 
            superClass = "replValue", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  if (strict) 
                    from <- from@.Data
                  {
                    class(from) <- "numeric"
                    from
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "replValue") <- value
                value <- .value
                {
                  .value <- as(from, "integer", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "integer", strict = FALSE)
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 3), ordered = new("SClassExtension", subClass = "ordered", 
            superClass = "replValue", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "factor")
                    else from
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    {
                      class(from) <- "numeric"
                      from
                    }
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "replValue") <- value
                value <- .value
                {
                  .value <- as(from, "factor", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    S3Part(from) <- value
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 4)), versionKey = <pointer: (nil)>, sealed = FALSE)


qr.fitted <- new("standardGeneric", .Data = function (qr, y, k = qr$rank) 
standardGeneric("qr.fitted"), generic = "qr.fitted", package = "base", 
    group = list(), valueClass = character(0), signature = c("qr", 
    "y", "k"), default = new("derivedDefaultMethod", .Data = function (qr, 
        y, k = qr$rank) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            stop("not implemented for complex 'qr'")
        if (isTRUE(attr(qr, "useLAPACK"))) 
            stop("not supported for LAPACK QR")
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        k <- as.integer(k)
        if (k > qr$rank) 
            stop("'k' is too large")
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        storage.mode(y) <- "double"
        .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, xb = y)$xb
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.fitted"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (qr, 
        y, k = qr$rank) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            stop("not implemented for complex 'qr'")
        if (isTRUE(attr(qr, "useLAPACK"))) 
            stop("not supported for LAPACK QR")
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        k <- as.integer(k)
        if (k > qr$rank) 
            stop("'k' is too large")
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        storage.mode(y) <- "double"
        .Fortran(.F_dqrxb, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, xb = y)$xb
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.fitted"))(qr, 
        y, k))


printSpMatrix2 <- function (x, digits = NULL, maxp = max(100L, getOption("max.print")), 
    zero.print = ".", col.names, note.dropping.colnames = TRUE, 
    uniDiag = TRUE, suppRows = NULL, suppCols = NULL, col.trailer = if (suppCols) "......" else "", 
    align = c("fancy", "right"), width = getOption("width"), 
    fitWidth = TRUE) 
{
    d <- dim(x)
    cl <- class(x)
    cld <- getClassDef(cl)
    xtra <- if (extends(cld, "triangularMatrix") && x@diag == 
        "U") 
        " (unitriangular)"
    else ""
    cat(sprintf("%d x %d sparse Matrix of class \"%s\"%s\n", 
        d[1], d[2], cl, xtra))
    setW <- !missing(width) && width > getOption("width")
    if (setW) {
        op <- options(width = width)
        on.exit(options(op))
    }
    if ((isFALSE(suppRows) && isFALSE(suppCols)) || (!isTRUE(suppRows) && 
        !isTRUE(suppCols) && prod(d) <= maxp)) {
        if (missing(col.trailer) && is.null(suppCols)) 
            suppCols <- FALSE
        printSpMatrix(x, cld = cld, digits = digits, maxp = maxp, 
            zero.print = zero.print, col.names = col.names, note.dropping.colnames = note.dropping.colnames, 
            uniDiag = uniDiag, col.trailer = col.trailer, align = align)
    }
    else {
        validObject(x)
        sTxt <- c(" ", gettext("in show(); maybe adjust 'options(max.print= *, width = *)'"), 
            "\n ..............................\n")
        useW <- width - (format.info(d[1], digits = digits)[1] + 
            3 + 1)
        if (is.null(suppCols)) 
            suppCols <- (d[2] * 2 > useW)
        nCc <- 1 + nchar(col.trailer, "width")
        if (suppCols) {
            nc <- (useW - nCc)%/%2
            x <- x[, 1:nc, drop = FALSE]
        }
        else nc <- d[2]
        nr <- maxp%/%nc
        if (is.null(suppRows)) 
            suppRows <- (nr < d[1])
        if (suppRows) {
            n2 <- ceiling(nr/2)
            nr1 <- min(d[1], max(1L, n2))
            nr2 <- max(1L, nr - n2)
            nr <- nr1 + nr2
            if (fitWidth) {
                cM <- formatSpMatrix(x[seq_len(nr1), , drop = FALSE], 
                  digits = digits, maxp = maxp, zero.print = zero.print, 
                  col.names = col.names, align = align, note.dropping.colnames = note.dropping.colnames, 
                  uniDiag = FALSE)
                matW <- nchar(capture.output(print(cM, quote = FALSE, 
                  right = FALSE))[[1]])
                needW <- matW + (if (suppCols) 
                  nCc
                else 0)
                if (needW > useW) {
                  op <- options(width = width + (needW - useW))
                  if (!setW) 
                    on.exit(options(op))
                }
            }
            printSpMatrix(x[seq_len(nr1), , drop = FALSE], digits = digits, 
                maxp = maxp, zero.print = zero.print, col.names = col.names, 
                note.dropping.colnames = note.dropping.colnames, 
                uniDiag = uniDiag, col.trailer = col.trailer, 
                align = align)
            suppTxt <- if (suppCols) 
                gettextf("suppressing %d columns and %d rows", 
                  d[2] - nc, d[1] - nr)
            else gettextf("suppressing %d rows", d[1] - nr)
            cat("\n ..............................", "\n ........", 
                suppTxt, sTxt, sep = "")
            printSpMatrix(tail(x, nr2), digits = digits, maxp = maxp, 
                zero.print = zero.print, col.names = col.names, 
                note.dropping.colnames = note.dropping.colnames, 
                uniDiag = FALSE, col.trailer = col.trailer, align = align)
        }
        else if (suppCols) {
            printSpMatrix(x[, 1:nc, drop = FALSE], digits = digits, 
                maxp = maxp, zero.print = zero.print, col.names = col.names, 
                note.dropping.colnames = note.dropping.colnames, 
                uniDiag = uniDiag, col.trailer = col.trailer, 
                align = align)
            cat("\n .....", gettextf("suppressing %d columns", 
                d[2] - nc), sTxt, sep = "")
        }
        else stop("logic programming error in printSpMatrix2(), please report")
        invisible(x)
    }
}


format <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("format"), generic = "format", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("format"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "format"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("format"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "format"))(x, 
        ...))


diagN2U <- function (x, cl = getClassDef(class(x)), checkDense = FALSE) 
{
    if (!(extends(cl, "triangularMatrix") && x@diag == "N")) 
        return(x)
    if (checkDense && extends(cl, "denseMatrix")) {
        .dense.diagN2U(x)
    }
    else .Call(Csparse_diagN2U, as(x, "CsparseMatrix"))
}


`.__T__Schur:Matrix` <- "<environment>"

.__C__ltpMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(ldenseMatrix = new("SClassExtension", subClass = "ltpMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("ltpMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ltpMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltpMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = "ltpMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltpMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltpMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ltpMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltpMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltpMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "ltpMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ltpMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


tail <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("tail"), generic = "tail", package = "utils", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("tail"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "tail"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("tail"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "tail"))(x, 
        ...))


.__C__sparseMatrix <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    Matrix = new("SClassExtension", subClass = "sparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "sparseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    Mnumeric = new("SClassExtension", subClass = "sparseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
    replValueSp = new("SClassExtension", subClass = "sparseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2)), 
    virtual = TRUE, prototype = S4_object(), validity = NULL, 
    access = list(), className = structure("sparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(diagonalMatrix = new("SClassExtension", 
        subClass = "diagonalMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("diagonalMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), TsparseMatrix = new("SClassExtension", 
        subClass = "TsparseMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CsparseMatrix = new("SClassExtension", 
        subClass = "CsparseMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), RsparseMatrix = new("SClassExtension", 
        subClass = "RsparseMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = "dsparseMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = "lsparseMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = "nsparseMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), indMatrix = new("SClassExtension", subClass = "indMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("indMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddiMatrix = new("SClassExtension", subClass = "ddiMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("diagonalMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ddiMatrix"), simple = TRUE, by = "diagonalMatrix", 
        dataPart = FALSE, distance = 2), ldiMatrix = new("SClassExtension", 
        subClass = "ldiMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("diagonalMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ldiMatrix"), simple = TRUE, by = "diagonalMatrix", 
        dataPart = FALSE, distance = 2), dgTMatrix = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), dtTMatrix = new("SClassExtension", 
        subClass = "dtTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), dsTMatrix = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), lgTMatrix = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), ltTMatrix = new("SClassExtension", 
        subClass = "ltTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), lsTMatrix = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), ngTMatrix = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), ntTMatrix = new("SClassExtension", 
        subClass = "ntTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), nsTMatrix = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 2), dgCMatrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), dtCMatrix = new("SClassExtension", 
        subClass = "dtCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), dsCMatrix = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), lgCMatrix = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), ltCMatrix = new("SClassExtension", 
        subClass = "ltCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), lsCMatrix = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), ngCMatrix = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), ntCMatrix = new("SClassExtension", 
        subClass = "ntCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), nsCMatrix = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("CsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 2), dgRMatrix = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), dtRMatrix = new("SClassExtension", 
        subClass = "dtRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), dsRMatrix = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), lgRMatrix = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), ltRMatrix = new("SClassExtension", 
        subClass = "ltRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), lsRMatrix = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), ngRMatrix = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), ntRMatrix = new("SClassExtension", 
        subClass = "ntRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), nsRMatrix = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("RsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 2), dgTMatrix = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgTMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dtTMatrix = new("SClassExtension", 
        subClass = "dtTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtTMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dsTMatrix = new("SClassExtension", 
        subClass = "dsTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsTMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dgCMatrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dtCMatrix = new("SClassExtension", 
        subClass = "dtCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dsCMatrix = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dgRMatrix = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgRMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dtRMatrix = new("SClassExtension", 
        subClass = "dtRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtRMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), dsRMatrix = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsRMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), lgTMatrix = new("SClassExtension", 
        subClass = "lgTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgTMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), ltTMatrix = new("SClassExtension", 
        subClass = "ltTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltTMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), lsTMatrix = new("SClassExtension", 
        subClass = "lsTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsTMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), lgCMatrix = new("SClassExtension", 
        subClass = "lgCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), ltCMatrix = new("SClassExtension", 
        subClass = "ltCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), lsCMatrix = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), lgRMatrix = new("SClassExtension", 
        subClass = "lgRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgRMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), ltRMatrix = new("SClassExtension", 
        subClass = "ltRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltRMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), lsRMatrix = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsRMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), ngTMatrix = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngTMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), ntTMatrix = new("SClassExtension", 
        subClass = "ntTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntTMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), nsTMatrix = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsTMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), ngCMatrix = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngCMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), ntCMatrix = new("SClassExtension", 
        subClass = "ntCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntCMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), nsCMatrix = new("SClassExtension", 
        subClass = "nsCMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsCMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), ngRMatrix = new("SClassExtension", 
        subClass = "ngRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngRMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), ntRMatrix = new("SClassExtension", 
        subClass = "ntRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntRMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), nsRMatrix = new("SClassExtension", 
        subClass = "nsRMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsRMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), pMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "sparseMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "sparseMatrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "indMatrix", dataPart = FALSE, 
        distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__&:base` <- "<environment>"

`.__T__lu:Matrix` <- "<environment>"

`.__T__%/%:base` <- "<environment>"

`.__T__Ops:base` <- "<environment>"

.diag2tT <- function (from, uplo = "U", kind = .M.kind(from)) 
{
    i <- if (from@diag == "U") 
        integer(0)
    else seq_len(from@Dim[1]) - 1L
    new(paste0(kind, "tTMatrix"), diag = from@diag, Dim = from@Dim, 
        Dimnames = from@Dimnames, uplo = uplo, x = from@x, i = i, 
        j = i)
}


.__C__dgCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    CsparseMatrix = new("SClassExtension", subClass = "dgCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("dgCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dgCMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dgCMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("dgCMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgCMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dCsparseMatrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "dCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dCsparseMatrix", dQuote("dgCMatrix"), "dCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dgCMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dgCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgCMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dgCMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgCMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), xMatrix = new("SClassExtension", 
        subClass = structure("dgCMatrix", package = "Matrix"), 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("dMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dsparseMatrix"), "dgCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dgCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dgCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dgCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dgCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xCMatrix_validate, object), access = list(), className = structure("dgCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__determinant:base` <- "<environment>"

`.__T__facmul:Matrix` <- "<environment>"

.__C__lsyMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(ldenseMatrix = new("SClassExtension", subClass = "lsyMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("lsyMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("lsyMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsyMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = "lsyMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsyMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsyMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lsyMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsyMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lsyMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsyMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "lsyMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("lsyMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


Matrix <- function (data = NA, nrow = 1, ncol = 1, byrow = FALSE, dimnames = NULL, 
    sparse = NULL, doDiag = TRUE, forceCheck = FALSE) 
{
    i.M <- is(data, "Matrix")
    sM <- FALSE
    if (i.M) {
        if (is(data, "diagonalMatrix")) 
            return(data)
        sV <- FALSE
    }
    else if (inherits(data, "table")) 
        class(data) <- "matrix"
    else if (is(data, "sparseVector")) {
        data <- spV2M(data, nrow, ncol, byrow = byrow)
        i.M <- sparse <- forceCheck <- sM <- sV <- TRUE
    }
    if (is.null(sparse1 <- sparse) && (i.M || is(data, "matrix"))) 
        sparse <- sparseDefault(data)
    doDN <- TRUE
    if (i.M) {
        if (!sV) {
            if (!missing(nrow) || !missing(ncol) || !missing(byrow)) 
                warning("'nrow', 'ncol', etc, are disregarded when 'data' is \"Matrix\" already")
            sM <- is(data, "sparseMatrix")
            if (!forceCheck && ((sparse && sM) || (!sparse && 
                !sM))) 
                return(data)
        }
    }
    else if (!is.matrix(data)) {
        if (is.object(data) || !is.atomic(data)) 
            data <- as.vector(data)
        if (length(data) == 1 && is0(data) && !identical(sparse, 
            FALSE)) {
            if (is.null(sparse)) 
                sparse1 <- sparse <- TRUE
            i.M <- sM <- TRUE
            if (missing(nrow)) 
                nrow <- ceiling(1/ncol)
            else if (missing(ncol)) 
                ncol <- ceiling(1/nrow)
            isSym <- nrow == ncol
            data <- new(paste0(if (is.numeric(data)) 
                "d"
            else if (is.logical(data)) 
                "l"
            else stop("invalid 'data'"), if (isSym) 
                "s"
            else "g", "CMatrix"), p = rep.int(0L, ncol + 1L), 
                Dim = as.integer(c(nrow, ncol)), Dimnames = if (is.null.DN(dimnames)) 
                  list(NULL, NULL)
                else dimnames)
        }
        else {
            data <- .External(Mmatrix, data, nrow, ncol, byrow, 
                dimnames, missing(nrow), missing(ncol))
            if (is.null(sparse)) 
                sparse <- sparseDefault(data)
        }
        doDN <- FALSE
    }
    else if (!missing(nrow) || !missing(ncol) || !missing(byrow)) 
        warning("'nrow', 'ncol', etc, are disregarded for matrix 'data'")
    if (doDN && !is.null(dimnames)) 
        dimnames(data) <- dimnames
    isSym <- isSymmetric(data)
    if ((isTri <- !isSym)) 
        isTri <- isTriangular(data)
    isDiag <- isSym
    if (isDiag) 
        isDiag <- doDiag && !isTRUE(sparse1) && nrow(data) > 
            1 && isDiagonal(data)
    if (isDiag) {
        data <- as(data, "diagonalMatrix")
        isSym <- FALSE
    }
    else if (sparse && !sM) 
        data <- as(data, "sparseMatrix")
    else if (!sparse) {
        if (i.M) {
            if (!is(data, "denseMatrix")) 
                data <- as(data, "denseMatrix")
        }
        else {
            ctype <- typeof(data)
            if (ctype == "complex") 
                stop("complex matrices not yet implemented in Matrix package")
            if (ctype == "integer") 
                storage.mode(data) <- "double"
            data <- new(paste0(.M.kind(data), "geMatrix"), Dim = dim(data), 
                Dimnames = .M.DN(data), x = c(data))
        }
    }
    if (isTri && !is(data, "triangularMatrix")) {
        data <- if (attr(isTri, "kind") == "L") 
            tril(data)
        else triu(data)
    }
    else if (isSym && !is(data, "symmetricMatrix")) 
        data <- forceSymmetric(data)
    data
}


.__C__index <- new("ClassUnionRepresentation", slots = list(), contains = list(), 
    virtual = TRUE, prototype = numeric(0), validity = NULL, 
    access = list(), className = structure("index", package = "Matrix"), 
    package = "Matrix", subclasses = list(numeric = new("SClassExtension", 
        subClass = "numeric", superClass = "index", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "index")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "index", dQuote("numeric"), "index", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), logical = new("SClassExtension", subClass = "logical", 
        superClass = "index", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "index")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "index", dQuote("logical"), "index", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), character = new("SClassExtension", subClass = "character", 
        superClass = "index", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "index")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "index", dQuote("character"), "index", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), integer = new("SClassExtension", subClass = "integer", 
        superClass = "index", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "numeric"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "numeric", TRUE)
            as(.value, "index") <- value
            value <- .value
            {
                class(value) <- "integer"
                value
            }
        }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2), 
        double = new("SClassExtension", subClass = "double", 
            superClass = "index", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  class(from) <- "numeric"
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "index") <- value
                value <- .value
                {
                  class(value) <- "double"
                  value
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 2), signature = new("SClassExtension", 
            subClass = "signature", superClass = "index", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "character", TRUE)
                as(.value, "index") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
            }, simple = TRUE, by = "character", dataPart = FALSE, 
            distance = 2), className = new("SClassExtension", 
            subClass = "className", superClass = "index", package = "Matrix", 
            coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "character", TRUE)
                as(.value, "index") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
            }, simple = TRUE, by = "character", dataPart = FALSE, 
            distance = 2), ObjectsWithPackage = new("SClassExtension", 
            subClass = "ObjectsWithPackage", superClass = "index", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            {
                if (strict) 
                  from <- from@.Data
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "character", TRUE)
                as(.value, "index") <- value
                value <- .value
                {
                  from@.Data <- as(value, "character", strict = FALSE)
                  from
                }
            }, simple = TRUE, by = "character", dataPart = FALSE, 
            distance = 2), factor = new("SClassExtension", subClass = "factor", 
            superClass = "index", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  if (strict) 
                    from <- from@.Data
                  {
                    class(from) <- "numeric"
                    from
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "index") <- value
                value <- .value
                {
                  .value <- as(from, "integer", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "integer", strict = FALSE)
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 3), ordered = new("SClassExtension", subClass = "ordered", 
            superClass = "index", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "factor")
                    else from
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    {
                      class(from) <- "numeric"
                      from
                    }
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "index") <- value
                value <- .value
                {
                  .value <- as(from, "factor", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    S3Part(from) <- value
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 4)), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__lgeMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    ldenseMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("lgeMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("lgeMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgeMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), geMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = "geMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "geMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "geMatrix", dQuote("lgeMatrix"), "geMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgeMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgeMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lgeMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgeMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lgeMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), xMatrix = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("lMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lgeMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lgeMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lgeMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lgeMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lgeMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("lgeMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__ltRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(RsparseMatrix = new("SClassExtension", subClass = "ltRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("ltRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("ltRMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("ltRMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ltRMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltRMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("ltRMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltRMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ltRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltRMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ltRMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltRMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ltRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ltRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ltRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ltRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ltRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "ltRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tRMatrix_validate, object), access = list(), className = structure("ltRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__any:base` <- "<environment>"

diff <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("diff"), generic = "diff", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("diff"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "diff"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("diff"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "diff"))(x, 
        ...))


.__C__dCHMsuper <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    super = structure("integer", package = "methods"), pi = structure("integer", package = "methods"), 
    px = structure("integer", package = "methods"), s = structure("integer", package = "methods"), 
    colcount = structure("integer", package = "methods"), perm = structure("integer", package = "methods"), 
    type = structure("integer", package = "methods"), Dim = structure("integer", package = "methods")), 
    contains = list(CHMsuper = new("SClassExtension", subClass = "dCHMsuper", 
        superClass = "CHMsuper", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsuper")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsuper", dQuote("dCHMsuper"), "CHMsuper", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMfactor = new("SClassExtension", subClass = "dCHMsuper", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsuper"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dCHMsuper"), simple = TRUE, by = "CHMsuper", dataPart = FALSE, 
        distance = 2), CholeskyFactorization = new("SClassExtension", 
        subClass = "dCHMsuper", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), "dCHMsuper"), simple = TRUE, by = "CHMsuper", 
        dataPart = FALSE, distance = 3), MatrixFactorization = new("SClassExtension", 
        subClass = "dCHMsuper", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as(as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), "CHMsuper"), "dCHMsuper"), simple = TRUE, 
        by = "CHMsuper", dataPart = FALSE, distance = 4)), virtual = FALSE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("dCHMsuper", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


formatSpMatrix <- function (x, digits = NULL, maxp = 1e+09, cld = getClassDef(class(x)), 
    zero.print = ".", col.names, note.dropping.colnames = TRUE, 
    uniDiag = TRUE, align = c("fancy", "right")) 
{
    stopifnot(extends(cld, "sparseMatrix"))
    validObject(x)
    d <- dim(x)
    unitD <- extends(cld, "triangularMatrix") && x@diag == "U"
    if (unitD) {
        if (extends(cld, "CsparseMatrix")) 
            x <- .Call(Csparse_diagU2N, x)
        else if (extends(cld, "TsparseMatrix")) 
            x <- .Call(Tsparse_diagU2N, x)
        else {
            kind <- .M.kind(x, cld)
            x <- .Call(Tsparse_diagU2N, as(as(x, paste0(kind, 
                "Matrix")), "TsparseMatrix"))
            cld <- getClassDef(class(x))
        }
    }
    if (maxp < 100) 
        maxp <- 100L
    if (prod(d) > maxp) {
        nr <- maxp%/%d[2]
        m <- as(x[1:max(1, nr), , drop = FALSE], "matrix")
    }
    else {
        m <- as(x, "matrix")
    }
    dn <- dimnames(m)
    binary <- extends(cld, "nsparseMatrix") || extends(cld, "indMatrix")
    logi <- binary || extends(cld, "lsparseMatrix")
    cx <- .formatSparseSimple(m, asLogical = logi, digits = digits, 
        col.names = col.names, note.dropping.colnames = note.dropping.colnames, 
        dn = dn)
    if (is.logical(zero.print)) 
        zero.print <- if (zero.print) 
            "0"
        else " "
    if (binary) {
        cx[!m] <- zero.print
        cx[m] <- "|"
    }
    else {
        d <- dim(cx)
        ne <- length(iN0 <- 1L + .Call(m_encodeInd, non0ind(x, 
            cld), di = d, FALSE, FALSE))
        if (0 < ne && (logi || ne < prod(d))) {
            cx <- formatSparseM(x, zero.print, align, m = m, 
                asLogical = logi, uniDiag = unitD & uniDiag, 
                digits = digits, cx = cx, iN0 = iN0, dn = dn)
        }
        else if (ne == 0) 
            cx[] <- zero.print
    }
    cx
}


.__C__lsCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(CsparseMatrix = new("SClassExtension", subClass = "lsCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("lsCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("lsCMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lsCMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("lsCMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsCMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lCsparseMatrix = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "lCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lCsparseMatrix", dQuote("lsCMatrix"), "lCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("lsCMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("lsCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsCMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lsCMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsCMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), xMatrix = new("SClassExtension", 
        subClass = structure("lsCMatrix", package = "Matrix"), 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("lMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lsparseMatrix"), "lsCMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lsCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lsCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "lsCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xCMatrix_validate, object), access = list(), className = structure("lsCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__lspMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(ldenseMatrix = new("SClassExtension", subClass = "lspMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("lspMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("lspMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lspMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = "lspMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lspMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lspMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lspMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lspMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lspMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lspMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "lspMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lspMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "lspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dspMatrix_validate, object), access = list(), className = structure("lspMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__ndenseMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(nMatrix = new("SClassExtension", subClass = "ndenseMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("ndenseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), denseMatrix = new("SClassExtension", subClass = structure("ndenseMatrix", package = "Matrix"), 
        superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ndenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xMatrix = new("SClassExtension", subClass = "ndenseMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("ndenseMatrix"), "xMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "ndenseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), simple = TRUE, by = "nMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "ndenseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), simple = TRUE, by = "nMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "ndenseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "ndenseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ndenseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ndenseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ngeMatrix = new("SClassExtension", 
        subClass = "ngeMatrix", superClass = "ndenseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ngeMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntrMatrix = new("SClassExtension", subClass = "ntrMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ntrMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntpMatrix = new("SClassExtension", subClass = "ntpMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("ntpMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsyMatrix = new("SClassExtension", subClass = "nsyMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("nsyMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nspMatrix = new("SClassExtension", subClass = "nspMatrix", 
        superClass = "ndenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ndenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ndenseMatrix", dQuote("nspMatrix"), "ndenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


bandSparse <- function (n, m = n, k, diagonals, symmetric = FALSE, giveCsparse = TRUE) 
{
    if (use.x <- !missing(diagonals)) 
        diag.isMat <- is.matrix(diagonals)
    len.k <- length(k)
    stopifnot(!use.x || is.list(diagonals) || diag.isMat, k == 
        as.integer(k), n == as.integer(n), m == as.integer(m))
    k <- as.integer(k)
    n <- as.integer(n)
    m <- as.integer(m)
    stopifnot(n >= 0, m >= 0, -n + 1 <= (mik <- min(k)), (mak <- max(k)) <= 
        m - 1)
    if (use.x) {
        if (diag.isMat) {
            if (ncol(diagonals) != len.k) 
                stop(gettextf("'diagonals' matrix must have %d columns (= length(k) )", 
                  len.k), domain = NA)
            getD <- function(j) diagonals[, j]
        }
        else {
            if (length(diagonals) != len.k) 
                stop(gettextf("'diagonals' must have the same length (%d) as 'k'", 
                  len.k), domain = NA)
            getD <- function(j) diagonals[[j]]
        }
    }
    sqr <- n == m
    if (symmetric) {
        if (!sqr) 
            stop("matrix can only be symmetric if square, but n != m")
        if (mik < 0 && mak > 0) 
            stop("for symmetric band matrix, only specify upper or lower triangle\n hence, all k must have the same sign")
    }
    else tri <- sqr && sign(mik) * sign(mak) >= 0
    dims <- c(n, m)
    k.lengths <- if (n >= m) {
        ifelse(k >= m - n, m - pmax(0, k), n + k)
    }
    else {
        ifelse(k >= -n + 1, n + pmin(0, k), m - k)
    }
    i <- j <- integer(sum(k.lengths))
    if (use.x) 
        x <- if (len.k > 0) 
            rep.int(getD(1)[1], length(i))
    off.i <- 0L
    for (s in seq_len(len.k)) {
        kk <- k[s]
        l.kk <- k.lengths[s]
        ii1 <- seq_len(l.kk)
        ind <- ii1 + off.i
        if (kk >= 0) {
            i[ind] <- ii1
            j[ind] <- ii1 + kk
        }
        else {
            i[ind] <- ii1 - kk
            j[ind] <- ii1
        }
        if (use.x) {
            xx <- getD(s)
            if (length(xx) < l.kk) 
                warning(gettextf("the %d-th (sub)-diagonal (k = %d) is too short; filling with NA's", 
                  s, kk), domain = NA)
            x[ind] <- xx[ii1]
        }
        off.i <- off.i + l.kk
    }
    if (symmetric) {
        UpLo <- if (min(k) >= 0) 
            "U"
        else "L"
        T <- if (use.x) {
            if (is.integer(x)) 
                x <- as.double(x)
            cc <- paste0(.M.kind(x), "sTMatrix")
            new(cc, i = i - 1L, j = j - 1L, x = x, Dim = dims, 
                uplo = UpLo)
        }
        else new("nsTMatrix", i = i - 1L, j = j - 1L, Dim = dims, 
            uplo = UpLo)
        if (giveCsparse) 
            as(T, "CsparseMatrix")
        else T
    }
    else {
        if (use.x) 
            sparseMatrix(i = i, j = j, x = x, dims = dims, triangular = tri, 
                giveCsparse = giveCsparse)
        else sparseMatrix(i = i, j = j, dims = dims, triangular = tri, 
            giveCsparse = giveCsparse)
    }
}


.__C__lMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(Matrix = new("SClassExtension", subClass = "lMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xMatrix = new("SClassExtension", subClass = "lMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("lMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "lMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "mMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "mMatrix", dQuote("Matrix"), "mMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "lMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "lMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
        replValueSp = new("SClassExtension", subClass = "lMatrix", 
            superClass = "replValueSp", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 2)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("lMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ldenseMatrix = new("SClassExtension", 
        subClass = "ldenseMatrix", superClass = "lMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = "lsparseMatrix", superClass = "lMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ldiMatrix = new("SClassExtension", subClass = "ldiMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldiMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgeMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lgeMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), ltrMatrix = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = "lMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltrMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), ltpMatrix = new("SClassExtension", 
        subClass = "ltpMatrix", superClass = "lMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltpMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), lsyMatrix = new("SClassExtension", 
        subClass = "lsyMatrix", superClass = "lMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsyMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), lspMatrix = new("SClassExtension", 
        subClass = "lspMatrix", superClass = "lMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lspMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


readHB <- function (file) 
{
    if (is.character(file)) 
        file <- if (file == "") 
            stdin()
        else file(file)
    if (!inherits(file, "connection")) 
        stop("'file' must be a character string or connection")
    if (!isOpen(file)) {
        open(file)
        on.exit(close(file))
    }
    hdr <- readLines(file, 4, ok = FALSE)
    ptrln <- as.integer(substr(hdr[2], 15, 28))
    indln <- as.integer(substr(hdr[2], 29, 42))
    valln <- as.integer(substr(hdr[2], 43, 56))
    rhsln <- as.integer(substr(hdr[2], 57, 70))
    if (!(t1 <- substr(hdr[3], 1, 1)) %in% c("C", "R", "P")) 
        stop(gettextf("Invalid storage type: %s", t1), domain = NA)
    if (t1 != "R") 
        stop("Only numeric sparse matrices allowed")
    if (!(t2 <- substr(hdr[3], 2, 2)) %in% c("H", "R", "S", "U", 
        "Z")) 
        stop(gettextf("Invalid storage format: %s", t2), domain = NA)
    if (!(t3 <- substr(hdr[3], 3, 3)) %in% c("A", "E")) 
        stop(gettextf("Invalid assembled indicator: %s", t3), 
            domain = NA)
    nr <- as.integer(substr(hdr[3], 15, 28))
    nc <- as.integer(substr(hdr[3], 29, 42))
    nz <- as.integer(substr(hdr[3], 43, 56))
    ptrfmt <- toupper(sub("[[:space:]]+$", "", substr(hdr[4], 
        1, 16)))
    indfmt <- toupper(sub("[[:space:]]+$", "", substr(hdr[4], 
        17, 32)))
    valfmt <- toupper(sub("[[:space:]]+$", "", substr(hdr[4], 
        33, 52)))
    if (!is.na(rhsln) && rhsln > 0) 
        readLines(file, 1, ok = FALSE)
    ptr <- readmany(file, ptrln, nc + 1, ptrfmt, as.integer)
    ind <- readmany(file, indln, nz, indfmt, as.integer)
    vals <- readmany(file, valln, nz, valfmt, as.numeric)
    if (t2 == "S") 
        new("dsCMatrix", uplo = "L", p = ptr - 1L, i = ind - 
            1L, x = vals, Dim = c(nr, nc))
    else new("dgCMatrix", p = ptr - 1L, i = ind - 1L, x = vals, 
        Dim = c(nr, nc))
}


coerce <- methods::coerce # re-exported from methods package

.diagU2N <- function (x, cl, checkDense = FALSE) 
{
    if (extends(cl, "CsparseMatrix")) 
        .Call(Csparse_diagU2N, x)
    else if (extends(cl, "TsparseMatrix")) 
        .Call(Tsparse_diagU2N, x)
    else {
        kind <- .M.kind(x, cl)
        if (checkDense && extends(cl, "denseMatrix")) {
            .dense.diagU2N(x, kind)
        }
        else {
            .Call(Tsparse_diagU2N, as(as(x, paste0(kind, "Matrix")), 
                "TsparseMatrix"))
        }
    }
}


Summary <- methods::Summary # re-exported from methods package

.asmatrix <- function (x) 
as(x, "matrix")


solve <- new("standardGeneric", .Data = function (a, b, ...) 
standardGeneric("solve"), generic = "solve", package = "base", 
    group = list(), valueClass = character(0), signature = c("a", 
    "b"), default = new("derivedDefaultMethod", .Data = function (a, 
        b, ...) 
    UseMethod("solve"), target = new("signature", .Data = "ANY", 
        names = "a", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "a", package = "methods"), generic = "solve"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (a, 
        b, ...) 
    UseMethod("solve"), target = new("signature", .Data = "ANY", 
        names = "a", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "a", package = "methods"), generic = "solve"))(a, 
        b, ...))


.__C__sparseLU <- new("classRepresentation", slots = list(L = structure("dtCMatrix", package = "Matrix"), 
    U = structure("dtCMatrix", package = "Matrix"), p = structure("integer", package = "methods"), 
    q = structure("integer", package = "methods"), Dim = structure("integer", package = "methods")), 
    contains = list(LU = new("SClassExtension", subClass = "sparseLU", 
        superClass = "LU", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "LU")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "LU", dQuote("sparseLU"), "LU", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), MatrixFactorization = new("SClassExtension", 
        subClass = "sparseLU", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("LU"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, "sparseLU"), simple = TRUE, by = "LU", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("sparseLU", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


isSymmetric <- new("standardGeneric", .Data = function (object, ...) 
standardGeneric("isSymmetric"), generic = "isSymmetric", package = "base", 
    group = list(), valueClass = character(0), signature = "object", 
    default = new("derivedDefaultMethod", .Data = function (object, 
        ...) 
    UseMethod("isSymmetric"), target = new("signature", .Data = "ANY", 
        names = "object", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "object", package = "methods"), 
        generic = "isSymmetric"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (object, ...) 
        UseMethod("isSymmetric"), target = new("signature", .Data = "ANY", 
            names = "object", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "object", package = "methods"), 
        generic = "isSymmetric"))(object, ...))


`.__T__show:methods` <- "<environment>"

rowMeans <- new("standardGeneric", .Data = function (x, na.rm = FALSE, dims = 1, 
    ...) 
standardGeneric("rowMeans"), generic = "rowMeans", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::rowMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "rowMeans"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        na.rm = FALSE, dims = 1, ...) 
    base::rowMeans(x, na.rm = na.rm, dims = dims, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "rowMeans"))(x, 
        na.rm, dims, ...))


.__C__lsRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("logical", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(RsparseMatrix = new("SClassExtension", subClass = "lsRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("lsRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsparseMatrix = new("SClassExtension", 
        subClass = structure("lsRMatrix", package = "Matrix"), 
        superClass = structure("lsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lsparseMatrix", dQuote("lsRMatrix"), "lsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("lsRMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("lsRMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("lsRMatrix", package = "Matrix"), 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("lsparseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsRMatrix"), simple = TRUE, by = "lsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("lsRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("lsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsRMatrix"), simple = TRUE, by = structure("lsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("lsRMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "lsRMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "lsRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "lsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tRMatrix_validate, object), access = list(), className = structure("lsRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__print:base` <- "<environment>"

Math <- methods::Math # re-exported from methods package

`.__T__drop:base` <- "<environment>"

image <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("image"), generic = "image", package = "graphics", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("image"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "image"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("image"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "image"))(x, 
        ...))


drop0 <- function (x, tol = 0, is.Csparse = NA) 
{
    .Call(Csparse_drop, if (isTRUE(is.Csparse) || is.na(is.Csparse) && 
        is(x, "CsparseMatrix")) x else as(x, "CsparseMatrix"), 
        tol)
}


Ops <- methods::Ops # re-exported from methods package

.__C__nCHMsimpl <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    i = structure("integer", package = "methods"), nz = structure("integer", package = "methods"), 
    nxt = structure("integer", package = "methods"), prv = structure("integer", package = "methods"), 
    colcount = structure("integer", package = "methods"), perm = structure("integer", package = "methods"), 
    type = structure("integer", package = "methods"), Dim = structure("integer", package = "methods")), 
    contains = list(CHMsimpl = new("SClassExtension", subClass = "nCHMsimpl", 
        superClass = "CHMsimpl", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsimpl")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsimpl", dQuote("nCHMsimpl"), "CHMsimpl", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMfactor = new("SClassExtension", subClass = "nCHMsimpl", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsimpl"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nCHMsimpl"), simple = TRUE, by = "CHMsimpl", dataPart = FALSE, 
        distance = 2), CholeskyFactorization = new("SClassExtension", 
        subClass = "nCHMsimpl", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), "nCHMsimpl"), simple = TRUE, by = "CHMsimpl", 
        dataPart = FALSE, distance = 3), MatrixFactorization = new("SClassExtension", 
        subClass = "nCHMsimpl", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as(as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), "CHMsimpl"), "nCHMsimpl"), simple = TRUE, 
        by = "CHMsimpl", dataPart = FALSE, distance = 4)), virtual = FALSE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("nCHMsimpl", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


c.sparseVector <- function (...) 
{
    svl <- lapply(list(...), as, Class = "sparseVector")
    ns <- vapply(svl, slot, 1, "length")
    if ((N <- sum(ns)) < .Machine$integer.max) {
        ns <- as.integer(ns)
        N <- as.integer(N)
    }
    narg <- length(ns)
    iss <- lapply(svl, slot, "i")
    ii <- unlist(iss) + rep(cumsum(c(0L, ns[-narg])), lengths(iss))
    has.x <- any(have.x <- vapply(svl, .hasSlot, logical(1L), 
        name = "x"))
    if (has.x) {
        cls <- if (any(vapply(svl, is, NA, "zsparseVector"))) 
            "zsparseVector"
        else if (any(vapply(svl, is, NA, "dsparseVector"))) 
            "dsparseVector"
        else if (any(vapply(svl, is, NA, "isparseVector"))) 
            "isparseVector"
        else "lsparseVector"
        if (!(all.x <- all(have.x))) 
            one <- if (identical(cls, "lsparseVector")) 
                TRUE
            else if (identical(cls, "isparseVector")) 
                1L
            else 1
        xx <- unlist(if (all.x) 
            lapply(svl, slot, "x")
        else lapply(seq_len(narg), function(i) {
            if (have.x[[i]]) 
                svl[[i]]@x
            else rep_len(one, length(iss[[i]]))
        }))
        new(cls, x = xx, i = ii, length = N)
    }
    else new("nsparseVector", i = ii, length = N)
}


determinant <- new("standardGeneric", .Data = function (x, logarithm = TRUE, 
    ...) 
standardGeneric("determinant"), generic = "determinant", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "logarithm"), default = new("derivedDefaultMethod", .Data = function (x, 
        logarithm = TRUE, ...) 
    base::determinant(x, logarithm, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "determinant"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        logarithm = TRUE, ...) 
    base::determinant(x, logarithm, ...), target = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "determinant"))(x, 
        logarithm, ...))


.symDiagonal <- function (n, x = rep.int(1, n), uplo = "U", kind) 
.sparseDiagonal(n, x, uplo, shape = "s", kind = kind)


.__C__iMatrix <- new("classRepresentation", slots = list(x = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(Matrix = new("SClassExtension", subClass = "iMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("iMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xMatrix = new("SClassExtension", subClass = "iMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("iMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "iMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "mMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "mMatrix", dQuote("Matrix"), "mMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "iMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "iMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("iMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
        replValueSp = new("SClassExtension", subClass = "iMatrix", 
            superClass = "replValueSp", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("iMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 2)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("iMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__ldiMatrix <- new("classRepresentation", slots = list(diag = structure("character", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    x = structure("logical", package = "methods")), contains = list(
    diagonalMatrix = new("SClassExtension", subClass = "ldiMatrix", 
        superClass = "diagonalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "diagonalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "diagonalMatrix", dQuote("ldiMatrix"), "diagonalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = structure("ldiMatrix", package = "Matrix"), 
        superClass = structure("lMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldiMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = "ldiMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("diagonalMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ldiMatrix"), simple = TRUE, by = "diagonalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ldiMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldiMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "ldiMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ldiMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "ldiMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldiMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "lMatrix", dataPart = FALSE, distance = 2), 
    Mnumeric = new("SClassExtension", subClass = "ldiMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ldiMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ldiMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ldiMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ldiMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__ngTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(TsparseMatrix = new("SClassExtension", subClass = "ngTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("ngTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("ngTMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ngTMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("ngTMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngTMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("ngTMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngTMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ngTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngTMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("ngTMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngTMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ngTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ngTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ngTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ngTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ngTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__qr.qy:base` <- "<environment>"

`.__T__t:base` <- "<environment>"

`.__T__*:base` <- "<environment>"

.__C__ltrMatrix <- new("classRepresentation", slots = list(x = structure("logical", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(ldenseMatrix = new("SClassExtension", subClass = "ltrMatrix", 
        superClass = "ldenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ldenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ldenseMatrix", dQuote("ltrMatrix"), "ldenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ltrMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ltrMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lMatrix = new("SClassExtension", subClass = "ltrMatrix", 
        superClass = "lMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltrMatrix"), simple = TRUE, by = "ldenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ldenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltrMatrix"), simple = TRUE, by = structure("ldenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ltrMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltrMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "lMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "lMatrix", dQuote("ldenseMatrix"), "lMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ltrMatrix"), simple = TRUE, by = "lMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "ltrMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ltrMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("lMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ldenseMatrix"), "ltrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("ltrMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


sparse.model.matrix <- function (object, data = environment(object), contrasts.arg = NULL, 
    xlev = NULL, transpose = FALSE, drop.unused.levels = FALSE, 
    row.names = TRUE, verbose = FALSE, ...) 
{
    t <- if (missing(data)) 
        terms(object)
    else terms(object, data = data)
    if (is.null(attr(data, "terms"))) 
        data <- model.frame(object, data, xlev = xlev)
    else {
        reorder <- match(sapply(attr(t, "variables"), deparse, 
            width.cutoff = 500)[-1L], names(data))
        if (anyNA(reorder)) 
            stop("model frame and formula mismatch in model.matrix()")
        if (!isSeq(reorder, ncol(data), Ostart = FALSE)) 
            data <- data[, reorder, drop = FALSE]
    }
    int <- attr(t, "response")
    if (length(data)) {
        contr.funs <- as.character(getOption("contrasts"))
        namD <- names(data)
        for (i in namD) if (is.character(data[[i]])) 
            data[[i]] <- factor(data[[i]])
        isF <- vapply(data, function(x) is.factor(x) || is.logical(x), 
            NA)
        isF[int] <- FALSE
        isOF <- vapply(data, is.ordered, NA)
        for (nn in namD[isF]) if (is.null(attr(data[[nn]], "contrasts"))) 
            contrasts(data[[nn]]) <- contr.funs[1 + isOF[nn]]
        if (!is.null(contrasts.arg) && is.list(contrasts.arg)) {
            if (is.null(namC <- names(contrasts.arg))) 
                stop("invalid 'contrasts.arg' argument")
            for (nn in namC) {
                if (is.na(ni <- match(nn, namD))) 
                  warning(gettextf("variable '%s' is absent, its contrast will be ignored", 
                    nn), domain = NA)
                else {
                  ca <- contrasts.arg[[nn]]
                  if (is.matrix(ca)) 
                    contrasts(data[[ni]], ncol(ca)) <- ca
                  else contrasts(data[[ni]]) <- contrasts.arg[[nn]]
                }
            }
        }
    }
    else {
        isF <- FALSE
        data <- cbind(data, x = 0)
    }
    if (verbose) {
        cat("model.spmatrix(t, data, ..)  with t =\n")
        str(t, give.attr = FALSE)
    }
    ans <- model.spmatrix(t, data, transpose = transpose, drop.unused.levels = drop.unused.levels, 
        row.names = row.names, verbose = verbose)
    attr(ans, "contrasts") <- lapply(data[isF], function(x) attr(x, 
        "contrasts"))
    ans
}


.__C__dgRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    RsparseMatrix = new("SClassExtension", subClass = "dgRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("dgRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dgRMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dgRMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("dgRMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgRMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dgRMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgRMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dgRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgRMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dgRMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgRMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dgRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dgRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dgRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dgRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dgRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(xRMatrix_validate, object), access = list(), className = structure("dgRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__triu:Matrix` <- "<environment>"

abIseq1 <- function (from = 1, to = 1) 
{
    stopifnot(length(from) == 1L, length(to) == 1L)
    to <- to - from
    new("abIndex", kind = "rleDiff", rleD = new("rleDiff", first = as.integer(from), 
        rle = .rle(lengths = abs(to), values = as.integer(sign(to)))))
}


`.__T__Logic:base` <- "<environment>"

`.__T__zapsmall:base` <- "<environment>"

`.__T__unpack:Matrix` <- "<environment>"

pack <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("pack"), generic = "pack", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x, ...) 
    stop("invalid call in method dispatch to 'pack' (no default method)", 
        domain = NA))(x, ...))


.__C__diagonalMatrix <- new("classRepresentation", slots = list(diag = structure("character", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(sparseMatrix = new("SClassExtension", subClass = "diagonalMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("diagonalMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "diagonalMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "diagonalMatrix", superClass = "mMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "diagonalMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "diagonalMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    {
        d <- object@Dim
        if (d[1] != (n <- d[2])) 
            return("matrix is not square")
        lx <- length(object@x)
        if (object@diag == "U") {
            if (lx != 0) 
                return("diag = \"U\" (identity matrix) requires empty 'x' slot")
        }
        else if (object@diag == "N") {
            if (lx != n) 
                return("diagonal matrix has 'x' slot of length != 'n'")
        }
        else return("diagonal matrix 'diag' slot must be \"U\" or \"N\"")
        TRUE
    }, access = list(), className = structure("diagonalMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ddiMatrix = new("SClassExtension", 
        subClass = "ddiMatrix", superClass = "diagonalMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "diagonalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "diagonalMatrix", dQuote("ddiMatrix"), "diagonalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ldiMatrix = new("SClassExtension", subClass = "ldiMatrix", 
        superClass = "diagonalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "diagonalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "diagonalMatrix", dQuote("ldiMatrix"), "diagonalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


`.__T__forceSymmetric:Matrix` <- "<environment>"

`.__T__skewpart:Matrix` <- "<environment>"

update <- new("standardGeneric", .Data = function (object, ...) 
standardGeneric("update"), generic = "update", package = "stats", 
    group = list(), valueClass = character(0), signature = "object", 
    default = new("derivedDefaultMethod", .Data = function (object, 
        ...) 
    UseMethod("update"), target = new("signature", .Data = "ANY", 
        names = "object", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "object", package = "methods"), 
        generic = "update"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (object, ...) 
        UseMethod("update"), target = new("signature", .Data = "ANY", 
            names = "object", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "object", package = "methods"), 
        generic = "update"))(object, ...))


.__C__dtpMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(ddenseMatrix = new("SClassExtension", subClass = "dtpMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dtpMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("dtpMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtpMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = "dtpMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtpMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtpMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("dtpMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtpMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtpMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "dtpMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtpMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dtpMatrix_validate, object), access = list(), className = structure("dtpMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(pCholesky = new("SClassExtension", 
        subClass = "pCholesky", superClass = "dtpMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            class(from) <- "dtpMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "dtpMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            value <- new("dtpMatrix")
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(value, what) <- slot(from, what)
            value
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__isparseVector <- new("classRepresentation", slots = list(x = structure("integer", package = "methods"), 
    length = structure("numeric", package = "methods"), i = structure("numeric", package = "methods")), 
    contains = list(sparseVector = new("SClassExtension", subClass = "isparseVector", 
        superClass = "sparseVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("isparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xsparseVector = new("SClassExtension", 
        subClass = "isparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("isparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), replValueSp = new("SClassExtension", subClass = "isparseVector", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("isparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "sparseVector", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        if (length(object@i) != length(object@x)) 
            "'i' and 'x' differ in length"
        else TRUE
    }, access = list(), className = structure("isparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.formatSparseSimple <- function (m, asLogical = FALSE, digits = NULL, col.names, note.dropping.colnames = TRUE, 
    dn = dimnames(m)) 
{
    stopifnot(is.logical(asLogical))
    if (asLogical) 
        cx <- array("N", dim(m), dimnames = dn)
    else {
        cx <- apply(m, 2, format, digits = digits)
        if (is.null(dim(cx))) {
            dim(cx) <- dim(m)
            dimnames(cx) <- dn
        }
    }
    if (missing(col.names)) 
        col.names <- {
            if (!is.null(cc <- getOption("sparse.colnames"))) 
                cc
            else if (is.null(dn[[2]])) 
                FALSE
            else {
                ncol(m) < 10
            }
        }
    if (identical(col.names, FALSE)) 
        cx <- emptyColnames(cx, msg.if.not.empty = note.dropping.colnames)
    else if (is.character(col.names)) {
        stopifnot(length(col.names) == 1)
        cn <- col.names
        switch(substr(cn, 1, 3), abb = {
            iarg <- as.integer(sub("^[^0-9]*", "", cn))
            colnames(cx) <- abbreviate(colnames(cx), minlength = iarg)
        }, sub = {
            iarg <- as.integer(sub("^[^0-9]*", "", cn))
            colnames(cx) <- substr(colnames(cx), 1, iarg)
        }, stop(gettextf("invalid 'col.names' string: %s", cn), 
            domain = NA))
    }
    cx
}


summary <- new("standardGeneric", .Data = function (object, ...) 
standardGeneric("summary"), generic = "summary", package = "base", 
    group = list(), valueClass = character(0), signature = "object", 
    default = new("derivedDefaultMethod", .Data = function (object, 
        ...) 
    UseMethod("summary"), target = new("signature", .Data = "ANY", 
        names = "object", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "object", package = "methods"), 
        generic = "summary"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (object, ...) 
        UseMethod("summary"), target = new("signature", .Data = "ANY", 
            names = "object", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "object", package = "methods"), 
        generic = "summary"))(object, ...))


uniqTsparse <- function (x, class.x = c(class(x))) 
{
    if (extends(class.x, "TsparseMatrix")) {
        tri <- extends(class.x, "triangularMatrix")
        .Call(Csparse_to_Tsparse, .Call(Tsparse_to_Csparse, x, 
            tri), tri)
    }
    else stop(gettextf("not yet implemented for class %s", dQuote(class.x)), 
        domain = NA)
}


isTriangular <- new("standardGeneric", .Data = function (object, upper = NA, 
    ...) 
standardGeneric("isTriangular"), generic = "isTriangular", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("object", 
    "upper"), default = NULL, skeleton = (function (object, upper = NA, 
        ...) 
    stop("invalid call in method dispatch to 'isTriangular' (no default method)", 
        domain = NA))(object, upper, ...))


.__C__ntTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    diag = structure("character", package = "methods")), contains = list(
    TsparseMatrix = new("SClassExtension", subClass = "ntTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("ntTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("ntTMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ntTMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ntTMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntTMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("ntTMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntTMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ntTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntTMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ntTMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntTMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "ntTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ntTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ntTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ntTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ntTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "ntTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ntTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


facmul <- new("standardGeneric", .Data = function (x, factor, y, transpose, 
    left, ...) 
standardGeneric("facmul"), generic = "facmul", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("x", 
    "factor", "y", "transpose", "left"), default = NULL, skeleton = (function (x, 
        factor, y, transpose, left, ...) 
    stop("invalid call in method dispatch to 'facmul' (no default method)", 
        domain = NA))(x, factor, y, transpose, left, ...))


qr <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("qr"), generic = "qr", package = "base", group = list(), 
    valueClass = character(0), signature = "x", default = new("derivedDefaultMethod", 
        .Data = function (x, ...) 
        UseMethod("qr"), target = new("signature", .Data = "ANY", 
            names = "x", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "qr"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (x, ...) 
        UseMethod("qr"), target = new("signature", .Data = "ANY", 
            names = "x", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "x", package = "methods"), 
        generic = "qr"))(x, ...))


.__C__CHMsimpl <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    i = structure("integer", package = "methods"), nz = structure("integer", package = "methods"), 
    nxt = structure("integer", package = "methods"), prv = structure("integer", package = "methods"), 
    colcount = structure("integer", package = "methods"), perm = structure("integer", package = "methods"), 
    type = structure("integer", package = "methods"), Dim = structure("integer", package = "methods")), 
    contains = list(CHMfactor = new("SClassExtension", subClass = "CHMsimpl", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsimpl"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CholeskyFactorization = new("SClassExtension", 
        subClass = "CHMsimpl", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), simple = TRUE, by = "CHMfactor", dataPart = FALSE, 
        distance = 2), MatrixFactorization = new("SClassExtension", 
        subClass = "CHMsimpl", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), "CHMsimpl"), simple = TRUE, by = "CHMfactor", 
        dataPart = FALSE, distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(CHMsimpl_validate, object), access = list(), className = structure("CHMsimpl", package = "Matrix"), 
    package = "Matrix", subclasses = list(dCHMsimpl = new("SClassExtension", 
        subClass = "dCHMsimpl", superClass = "CHMsimpl", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsimpl")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsimpl", dQuote("dCHMsimpl"), "CHMsimpl", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nCHMsimpl = new("SClassExtension", subClass = "nCHMsimpl", 
        superClass = "CHMsimpl", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsimpl")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsimpl", dQuote("nCHMsimpl"), "CHMsimpl", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__MatrixFactorization <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods")), 
    contains = structure(list(), .Names = character(0)), virtual = TRUE, 
    prototype = S4_object(), validity = function (object) 
    .Call(MatrixFactorization_validate, object), access = list(), 
    className = structure("MatrixFactorization", package = "Matrix"), 
    package = "Matrix", subclasses = list(CholeskyFactorization = new("SClassExtension", 
        subClass = "CholeskyFactorization", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("BunchKaufman"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("pBunchKaufman"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), LU = new("SClassExtension", subClass = "LU", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("LU"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseQR = new("SClassExtension", subClass = "sparseQR", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("sparseQR"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Schur = new("SClassExtension", subClass = "Schur", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("Schur"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Cholesky = new("SClassExtension", subClass = "Cholesky", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "Cholesky"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 2), pCholesky = new("SClassExtension", 
        subClass = "pCholesky", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "pCholesky"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 2), CHMfactor = new("SClassExtension", 
        subClass = "CHMfactor", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 2), denseLU = new("SClassExtension", 
        subClass = "denseLU", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("LU"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, "denseLU"), simple = TRUE, by = "LU", dataPart = FALSE, 
        distance = 2), sparseLU = new("SClassExtension", subClass = "sparseLU", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("LU"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, "sparseLU"), simple = TRUE, by = "LU", dataPart = FALSE, 
        distance = 2), CHMsuper = new("SClassExtension", subClass = "CHMsuper", 
        superClass = "MatrixFactorization", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 3), CHMsimpl = new("SClassExtension", 
        subClass = "CHMsimpl", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsimpl"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 3), dCHMsuper = new("SClassExtension", 
        subClass = "dCHMsuper", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dCHMsuper"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 4), nCHMsuper = new("SClassExtension", 
        subClass = "nCHMsuper", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nCHMsuper"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 4), dCHMsimpl = new("SClassExtension", 
        subClass = "dCHMsimpl", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dCHMsimpl"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 4), nCHMsimpl = new("SClassExtension", 
        subClass = "nCHMsimpl", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nCHMsimpl"), simple = TRUE, by = "CholeskyFactorization", 
        dataPart = FALSE, distance = 4)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__BunchKaufman:Matrix` <- "<environment>"

.updateCHMfactor <- function (object, parent, mult) 
.Call(CHMfactor_update, object, parent, mult)


.__C__dsyMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(ddenseMatrix = new("SClassExtension", subClass = "dsyMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dsyMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("dsyMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsyMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = "dsyMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsyMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsyMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dsyMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsyMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dsyMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsyMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "dsyMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dsyMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("dsyMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(dpoMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "dsyMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "dsyMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), corMatrix = new("SClassExtension", subClass = "corMatrix", 
        superClass = "dsyMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                class(from) <- "dsyMatrix"
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "dsyMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE)


Hilbert <- function (n) 
{
    n <- as.integer(n)
    i <- seq_len(n)
    new("dpoMatrix", x = c(1/outer(i - 1L, i, "+")), Dim = c(n, 
        n))
}


`.__T__!:base` <- "<environment>"

.__C__dgeMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    ddenseMatrix = new("SClassExtension", subClass = "dgeMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dgeMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("dgeMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgeMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), geMatrix = new("SClassExtension", subClass = "dgeMatrix", 
        superClass = "geMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "geMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "geMatrix", dQuote("dgeMatrix"), "geMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = "dgeMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgeMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgeMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dgeMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgeMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dgeMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), xMatrix = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("dMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dgeMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dgeMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dgeMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dgeMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dgeMatrix_validate, object), access = list(), className = structure("dgeMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__dtRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(RsparseMatrix = new("SClassExtension", subClass = "dtRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("dtRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dtRMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dtRMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("dtRMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtRMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dtRMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtRMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dtRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtRMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("dtRMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtRMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "dtRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dtRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dtRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dtRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dtRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dtRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tRMatrix_validate, object), access = list(), className = structure("dtRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__cbind2:methods` <- "<environment>"

`.__T__Math2:methods` <- "<environment>"

.__C__nsparseMatrix <- new("classRepresentation", slots = list(Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    nMatrix = new("SClassExtension", subClass = "nsparseMatrix", 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = structure("nsparseMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "nsparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nsparseMatrix"), simple = TRUE, by = "nMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "nsparseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "nsparseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "nsparseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("nMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "nsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("nsparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ngTMatrix = new("SClassExtension", 
        subClass = "ngTMatrix", superClass = "nsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ngTMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntTMatrix = new("SClassExtension", subClass = "ntTMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ntTMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsTMatrix = new("SClassExtension", subClass = "nsTMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("nsTMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngCMatrix = new("SClassExtension", subClass = "ngCMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ngCMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntCMatrix = new("SClassExtension", subClass = "ntCMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ntCMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsCMatrix = new("SClassExtension", subClass = "nsCMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("nsCMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngRMatrix = new("SClassExtension", subClass = "ngRMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ngRMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntRMatrix = new("SClassExtension", subClass = "ntRMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ntRMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsRMatrix = new("SClassExtension", subClass = "nsRMatrix", 
        superClass = "nsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("nsRMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


.solve.dgC.chol <- function (x, y) 
.Call(dgCMatrix_cholsol, as(x, "CsparseMatrix"), y)


`.__T__dim<-:base` <- "<environment>"

`.__T__band:Matrix` <- "<environment>"

toeplitz <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("toeplitz"), generic = "toeplitz", package = "stats", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    stats::toeplitz(x), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "toeplitz"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    stats::toeplitz(x), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "toeplitz"))(x, 
        ...))


.__C__dsCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(CsparseMatrix = new("SClassExtension", subClass = "dsCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("dsCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dsCMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dsCMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("dsCMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsCMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dCsparseMatrix = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "dCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dCsparseMatrix", dQuote("dsCMatrix"), "dCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dsCMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dsCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsCMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dsCMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsCMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), xMatrix = new("SClassExtension", 
        subClass = structure("dsCMatrix", package = "Matrix"), 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("dMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dsparseMatrix"), "dsCMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dsCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dsCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dsCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "dsCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tCMatrix_validate, object), access = list(), className = structure("dsCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__dspMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(ddenseMatrix = new("SClassExtension", subClass = "dspMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dspMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("dspMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dspMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = "dspMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dspMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dspMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dspMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dspMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dspMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dspMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "dspMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dspMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dspMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dspMatrix_validate, object), access = list(), className = structure("dspMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dppMatrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = "dspMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            class(from) <- "dspMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


rBind <- function (..., deparse.level = 1) 
{
    if (is.null(wrn <- get0("warned.rBind", .MatrixEnv)) || isTRUE(getOption("Matrix.warn")) || 
        isTRUE(getOption("Matrix.verbose"))) {
        if (is.null(wrn)) 
            assign("warned.rBind", TRUE, envir = .MatrixEnv)
        .Deprecated(msg = "'rBind' is deprecated.\n Since R version 3.2.0, base's rbind() should work fine with S4 objects")
    }
    base::rbind(..., deparse.level = deparse.level)
}


`.__T__diff:base` <- "<environment>"

nearPD <- function (x, corr = FALSE, keepDiag = FALSE, do2eigen = TRUE, 
    doSym = FALSE, doDykstra = TRUE, only.values = FALSE, ensureSymmetry = !isSymmetric(x), 
    eig.tol = 1e-06, conv.tol = 1e-07, posd.tol = 1e-08, maxit = 100, 
    conv.norm.type = "I", trace = FALSE) 
{
    if (ensureSymmetry) {
        x <- symmpart(x)
    }
    n <- ncol(x)
    if (keepDiag) 
        diagX0 <- diag(x)
    if (doDykstra) {
        D_S <- x
        D_S[] <- 0
    }
    X <- x
    iter <- 0
    converged <- FALSE
    conv <- Inf
    while (iter < maxit && !converged) {
        Y <- X
        if (doDykstra) 
            R <- Y - D_S
        e <- eigen(if (doDykstra) 
            R
        else Y, symmetric = TRUE)
        Q <- e$vectors
        d <- e$values
        p <- d > eig.tol * d[1]
        if (!any(p)) 
            stop("Matrix seems negative semi-definite")
        Q <- Q[, p, drop = FALSE]
        X <- tcrossprod(Q * rep(d[p], each = nrow(Q)), Q)
        if (doDykstra) 
            D_S <- X - R
        if (doSym) 
            X <- (X + t(X))/2
        if (corr) 
            diag(X) <- 1
        else if (keepDiag) 
            diag(X) <- diagX0
        conv <- norm(Y - X, conv.norm.type)/norm(Y, conv.norm.type)
        iter <- iter + 1
        if (trace) 
            cat(sprintf("iter %3d : #{p}=%d, ||Y-X|| / ||Y||= %11g\n", 
                iter, sum(p), conv))
        converged <- (conv <= conv.tol)
    }
    if (!converged) 
        warning(gettextf("'nearPD()' did not converge in %d iterations", 
            iter), domain = NA)
    if (do2eigen || only.values) {
        e <- eigen(X, symmetric = TRUE)
        d <- e$values
        Eps <- posd.tol * abs(d[1])
        if (d[n] < Eps) {
            d[d < Eps] <- Eps
            if (!only.values) {
                Q <- e$vectors
                o.diag <- diag(X)
                X <- Q %*% (d * t(Q))
                D <- sqrt(pmax(Eps, o.diag)/diag(X))
                X[] <- D * X * rep(D, each = n)
            }
        }
        if (only.values) 
            return(d)
        if (corr) 
            diag(X) <- 1
        else if (keepDiag) 
            diag(X) <- diagX0
    }
    structure(list(mat = new("dpoMatrix", x = as.vector(X), Dim = c(n, 
        n), Dimnames = .M.DN(x)), eigenvalues = d, corr = corr, 
        normF = norm(x - X, "F"), iterations = iter, rel.tol = conv, 
        converged = converged), class = "nearPD")
}


`.__T__image:graphics` <- "<environment>"

print <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("print"), generic = "print", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("print"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "print"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("print"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "print"))(x, 
        ...))


.__C__pMatrix <- new("classRepresentation", slots = list(perm = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    indMatrix = new("SClassExtension", subClass = "pMatrix", 
        superClass = "indMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "indMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("perm", "Dim", "Dimnames", "factors"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "sparseMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "sparseMatrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "indMatrix", dataPart = FALSE, 
        distance = 2), generalMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "generalMatrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("indMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "compMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("indMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), Matrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("indMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 4), mMatrix = new("SClassExtension", 
        subClass = "pMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "indMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 5), 
    Mnumeric = new("SClassExtension", subClass = "pMatrix", superClass = "Mnumeric", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "indMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 5), 
    replValueSp = new("SClassExtension", subClass = "pMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "indMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "Matrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 5)), 
    virtual = FALSE, prototype = S4_object(), validity = function (object) 
    {
        d <- object@Dim
        if (d[2] != (n <- d[1])) 
            return("pMatrix must be square")
        perm <- object@perm
        if (length(perm) != n) 
            return(paste("length of 'perm' slot must be", n))
        if (n > 0 && !(all(range(perm) == c(1, n)) && length(unique(perm)) == 
            n)) 
            return("'perm' slot is not a valid permutation")
        TRUE
    }, access = list(), className = structure("pMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__nsTMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    factors = structure("list", package = "methods")), contains = list(
    TsparseMatrix = new("SClassExtension", subClass = "nsTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("nsTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("nsTMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("nsTMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("nsTMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("nsTMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("nsTMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsTMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("nsTMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsTMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("nsTMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nsTMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "nsTMatrix"), simple = TRUE, by = "TsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "nsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "nsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "nsTMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), "nsTMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("nsTMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__toeplitz:stats` <- "<environment>"

`.__T__tcrossprod:base` <- "<environment>"

.__C__compMatrix <- new("classRepresentation", slots = list(factors = structure("list", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(Matrix = new("SClassExtension", subClass = "compMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "compMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
        Mnumeric = new("SClassExtension", subClass = "compMatrix", 
            superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("compMatrix"), "Matrix", 
                    dQuote(class(value))), domain = NA)
                value
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 2), replValueSp = new("SClassExtension", 
            subClass = "compMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("compMatrix"), "Matrix", 
                    dQuote(class(value))), domain = NA)
                value
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 2)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("compMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(generalMatrix = new("SClassExtension", 
        subClass = "generalMatrix", superClass = "compMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = "symmetricMatrix", superClass = "compMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dpoMatrix = new("SClassExtension", subClass = "dpoMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dsyMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dsyMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dsyMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), dppMatrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = "compMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                class(from) <- "dspMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dspMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("dspMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3), corMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = "compMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 4), pMatrix = new("SClassExtension", subClass = "pMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "compMatrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = structure("indMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 3)), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


diagU2N <- function (x, cl = getClassDef(class(x)), checkDense = FALSE) 
{
    if (extends(cl, "triangularMatrix") && x@diag == "U") 
        .diagU2N(x, cl, checkDense = checkDense)
    else x
}


.__C__generalMatrix <- new("classRepresentation", slots = list(factors = structure("list", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(compMatrix = new("SClassExtension", subClass = "generalMatrix", 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "generalMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "generalMatrix"), simple = TRUE, by = "compMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "generalMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "generalMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "generalMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "generalMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "generalMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("compMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "generalMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("generalMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dgeMatrix = new("SClassExtension", 
        subClass = "dgeMatrix", superClass = "generalMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgeMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgeMatrix = new("SClassExtension", subClass = "lgeMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgeMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngeMatrix = new("SClassExtension", subClass = "ngeMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngeMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgTMatrix = new("SClassExtension", subClass = "dgTMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgTMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgCMatrix = new("SClassExtension", subClass = "dgCMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgCMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgRMatrix = new("SClassExtension", subClass = "dgRMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("dgRMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgTMatrix = new("SClassExtension", subClass = "lgTMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgTMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgCMatrix = new("SClassExtension", subClass = "lgCMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgCMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgRMatrix = new("SClassExtension", subClass = "lgRMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("lgRMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngTMatrix = new("SClassExtension", subClass = "ngTMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        as(from, "ngeMatrix"), test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngTMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = FALSE, by = character(0), dataPart = FALSE, 
        distance = 1), ngCMatrix = new("SClassExtension", subClass = "ngCMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngCMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngRMatrix = new("SClassExtension", subClass = "ngRMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngRMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), indMatrix = new("SClassExtension", subClass = "indMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("indMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), pMatrix = new("SClassExtension", subClass = "pMatrix", 
        superClass = "generalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "indMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "indMatrix", TRUE)
            as(.value, "generalMatrix") <- value
            value <- .value
            {
                for (what in c("perm", "Dim", "Dimnames", "factors"
                )) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "indMatrix", dataPart = FALSE, 
        distance = 2)), versionKey = <pointer: (nil)>, sealed = FALSE)


tril <- new("standardGeneric", .Data = function (x, k = 0, ...) 
standardGeneric("tril"), generic = "tril", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("x", 
    "k"), default = NULL, skeleton = (function (x, k = 0, ...) 
    stop("invalid call in method dispatch to 'tril' (no default method)", 
        domain = NA))(x, k, ...))


.SuiteSparse_version <- function () 
{
    ssv <- .Call(get_SuiteSparse_version)
    package_version(list(major = ssv[1], minor = paste(ssv[2:3], 
        collapse = ".")))
}


.__C__dsRMatrix <- new("classRepresentation", slots = list(p = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), x = structure("numeric", package = "methods"), 
    uplo = structure("character", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(RsparseMatrix = new("SClassExtension", subClass = "dsRMatrix", 
        superClass = "RsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "RsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "RsparseMatrix", dQuote("dsRMatrix"), "RsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = structure("dsRMatrix", package = "Matrix"), 
        superClass = structure("dsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dsRMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), symmetricMatrix = new("SClassExtension", 
        subClass = structure("dsRMatrix", package = "Matrix"), 
        superClass = structure("symmetricMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "symmetricMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "symmetricMatrix", dQuote("dsRMatrix"), "symmetricMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("dsRMatrix", package = "Matrix"), 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsRMatrix"), simple = TRUE, by = "dsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("dsRMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsRMatrix"), simple = TRUE, by = structure("dsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("dsRMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("symmetricMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsRMatrix"), simple = TRUE, by = "symmetricMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dsRMatrix"), simple = TRUE, by = "RsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dsRMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "RsparseMatrix"), "dsRMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(tRMatrix_validate, object), access = list(), className = structure("dsRMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.solve.dgC.lu <- function (a, b, tol = .Machine$double.eps) 
{
    lu.a <- LU.dgC(a)
    if (tol > 0) {
        rU <- range(abs(diag(lu.a@U)))
        if (rU[1]/rU[2] < tol) 
            stop(gettextf("LU computationally singular: ratio of extreme entries in |diag(U)| = %9.4g", 
                rU[1]/rU[2]), domain = NA)
    }
    n <- dim(a)[1L]
    b.isMat <- if (missing(b)) {
        b <- .sparseDiagonal(n)
        TRUE
    }
    else {
        isM <- !is.null(dim(b))
        if (isM && nrow(b) != n) 
            stop("RHS 'b' has wrong number of rows:", nrow(b))
        if (!isM && length(b) != n) 
            stop("RHS 'b' has wrong length", length(b))
        isM
    }
    bp <- if (b.isMat) 
        b[lu.a@p + 1L, ]
    else b[lu.a@p + 1L]
    R <- solve(lu.a@U, solve(lu.a@L, bp))
    R[invPerm(lu.a@q, zero.p = TRUE), ]
}


.__C__ntCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), uplo = structure("character", package = "methods"), 
    diag = structure("character", package = "methods")), contains = list(
    CsparseMatrix = new("SClassExtension", subClass = "ntCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("ntCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("ntCMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ntCMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("ntCMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("ntCMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nCsparseMatrix = new("SClassExtension", 
        subClass = "ntCMatrix", superClass = "nCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nCsparseMatrix", dQuote("ntCMatrix"), "nCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("ntCMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntCMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ntCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntCMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ntCMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntCMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = structure("ntCMatrix", package = "Matrix"), 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ntCMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 3), Mnumeric = new("SClassExtension", 
        subClass = "ntCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ntCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ntCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ntCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ntCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__Arith:base` <- "<environment>"

show <- methods::show # re-exported from methods package

`.__T__Compare:methods` <- "<environment>"

chol <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("chol"), generic = "chol", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("chol"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "chol"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("chol"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "chol"))(x, 
        ...))


triu <- new("standardGeneric", .Data = function (x, k = 0, ...) 
standardGeneric("triu"), generic = "triu", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("x", 
    "k"), default = NULL, skeleton = (function (x, k = 0, ...) 
    stop("invalid call in method dispatch to 'triu' (no default method)", 
        domain = NA))(x, k, ...))


`.__T__rep:base` <- "<environment>"

all.equal <- new("standardGeneric", .Data = function (target, current, ...) 
standardGeneric("all.equal"), generic = "all.equal", package = "base", 
    group = list(), valueClass = character(0), signature = c("target", 
    "current"), default = new("derivedDefaultMethod", .Data = function (target, 
        current, ...) 
    UseMethod("all.equal"), target = new("signature", .Data = "ANY", 
        names = "target", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "target", package = "methods"), 
        generic = "all.equal"), skeleton = (new("derivedDefaultMethod", 
        .Data = function (target, current, ...) 
        UseMethod("all.equal"), target = new("signature", .Data = "ANY", 
            names = "target", package = "methods"), defined = new("signature", 
            .Data = "ANY", names = "target", package = "methods"), 
        generic = "all.equal"))(target, current, ...))


.__C__number <- new("ClassUnionRepresentation", slots = list(), contains = list(), 
    virtual = TRUE, prototype = numeric(0), validity = NULL, 
    access = list(), className = structure("number", package = "Matrix"), 
    package = "Matrix", subclasses = list(numeric = new("SClassExtension", 
        subClass = "numeric", superClass = "number", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "number")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "number", dQuote("numeric"), "number", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), complex = new("SClassExtension", subClass = "complex", 
        superClass = "number", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "number")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "number", dQuote("complex"), "number", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), integer = new("SClassExtension", subClass = "integer", 
        superClass = "number", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "numeric"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "numeric", TRUE)
            as(.value, "number") <- value
            value <- .value
            {
                class(value) <- "integer"
                value
            }
        }, simple = TRUE, by = "numeric", dataPart = FALSE, distance = 2), 
        double = new("SClassExtension", subClass = "double", 
            superClass = "number", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  class(from) <- "numeric"
                  from
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "number") <- value
                value <- .value
                {
                  class(value) <- "double"
                  value
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 2), factor = new("SClassExtension", subClass = "factor", 
            superClass = "number", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  if (strict) 
                    from <- from@.Data
                  {
                    class(from) <- "numeric"
                    from
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "number") <- value
                value <- .value
                {
                  .value <- as(from, "integer", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    from@.Data <- as(value, "integer", strict = FALSE)
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 3), ordered = new("SClassExtension", subClass = "ordered", 
            superClass = "number", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            {
                from <- {
                  from <- {
                    if (strict) 
                      S3Part(from, S3Class = "factor")
                    else from
                  }
                  {
                    if (strict) 
                      from <- from@.Data
                    {
                      class(from) <- "numeric"
                      from
                    }
                  }
                }
                from
            }, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                .value <- as(from, "numeric", TRUE)
                as(.value, "number") <- value
                value <- .value
                {
                  .value <- as(from, "factor", TRUE)
                  as(.value, "numeric") <- value
                  value <- .value
                  {
                    S3Part(from) <- value
                    from
                  }
                }
            }, simple = TRUE, by = "numeric", dataPart = FALSE, 
            distance = 4)), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__ddiMatrix <- new("classRepresentation", slots = list(diag = structure("character", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    x = structure("numeric", package = "methods")), contains = list(
    diagonalMatrix = new("SClassExtension", subClass = "ddiMatrix", 
        superClass = "diagonalMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "diagonalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "diagonalMatrix", dQuote("ddiMatrix"), "diagonalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = structure("ddiMatrix", package = "Matrix"), 
        superClass = structure("dMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddiMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = "ddiMatrix", superClass = "sparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("diagonalMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ddiMatrix"), simple = TRUE, by = "diagonalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("ddiMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddiMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "ddiMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ddiMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "ddiMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddiMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "dMatrix", dataPart = FALSE, distance = 2), 
    Mnumeric = new("SClassExtension", subClass = "ddiMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ddiMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ddiMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "diagonalMatrix"), "ddiMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ddiMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__sum:base` <- "<environment>"

`.__T__norm:base` <- "<environment>"

`.__T__pack:Matrix` <- "<environment>"

.__C__dtrMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    uplo = structure("character", package = "methods"), diag = structure("character", package = "methods")), 
    contains = list(ddenseMatrix = new("SClassExtension", subClass = "dtrMatrix", 
        superClass = "ddenseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "ddenseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "ddenseMatrix", dQuote("dtrMatrix"), "ddenseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), triangularMatrix = new("SClassExtension", 
        subClass = structure("dtrMatrix", package = "Matrix"), 
        superClass = structure("triangularMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "triangularMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "triangularMatrix", dQuote("dtrMatrix"), "triangularMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dMatrix = new("SClassExtension", subClass = "dtrMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtrMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), denseMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = structure("denseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "denseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "denseMatrix", dQuote("ddenseMatrix"), "denseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtrMatrix"), simple = TRUE, by = structure("ddenseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = structure("dtrMatrix", package = "Matrix"), 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("triangularMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtrMatrix"), simple = TRUE, by = "triangularMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), xMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = "xMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtrMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "dtrMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "ddenseMatrix"), "dtrMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dense_nonpacked_validate, object), access = list(), 
    className = structure("dtrMatrix", package = "Matrix"), package = "Matrix", 
    subclasses = list(Cholesky = new("SClassExtension", subClass = "Cholesky", 
        superClass = "dtrMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            class(from) <- "dtrMatrix"
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "dtrMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        {
            value <- new("dtrMatrix")
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(value, what) <- slot(from, what)
            value
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            for (what in c("x", "Dim", "Dimnames", "uplo", "diag"
            )) slot(from, what) <- slot(value, what)
            from
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


fac2sparse <- function (from, to = c("d", "i", "l", "n", "z"), drop.unused.levels = TRUE, 
    giveCsparse = TRUE) 
{
    fact <- if (drop.unused.levels) 
        factor(from)
    else as.factor(from)
    levs <- levels(fact)
    n <- length(fact)
    to <- match.arg(to)
    i <- as.integer(fact) - 1L
    df <- data.frame(i = i, j = if (n) 
        0:(n - 1L)
    else integer())[!is.na(i), ]
    if (to != "n") 
        df$x <- rep.int(switch(to, d = 1, i = 1L, l = TRUE, z = 1 + 
            (0+0i)), nrow(df))
    T <- do.call(new, c(list(Class = paste0(to, "gTMatrix"), 
        Dim = c(length(levs), n), Dimnames = list(levs, names(fact))), 
        df))
    if (giveCsparse) 
        .Call(Tsparse_to_Csparse, T, FALSE)
    else T
}


det <- function (x, ...) 
{
    z <- determinant(x, logarithm = TRUE, ...)
    c(z$sign * exp(z$modulus))
}


`.__T__expm:Matrix` <- "<environment>"

`.__T__+:base` <- "<environment>"

.m2ngC <- function (from) 
{
    if (!is.logical(from)) 
        storage.mode(from) <- "logical"
    if (anyNA(from)) 
        stop("cannot coerce NA values to pattern \"ngCMatrix\"")
    .Call(matrix_to_Csparse, from, "ngCMatrix")
}


formatSparseM <- function (x, zero.print = ".", align = c("fancy", "right"), m = as(x, 
    "matrix"), asLogical = NULL, uniDiag = NULL, digits = NULL, 
    cx, iN0, dn = dimnames(m)) 
{
    cld <- getClassDef(class(x))
    if (is.null(asLogical)) {
        binary <- extends(cld, "nsparseMatrix") || extends(cld, 
            "indMatrix")
        asLogical <- {
            binary || extends(cld, "lsparseMatrix") || extends(cld, 
                "matrix") && is.logical(x)
        }
    }
    if (missing(cx)) 
        cx <- .formatSparseSimple(m, asLogical = asLogical, digits = digits, 
            dn = dn)
    if (is.null(d <- dim(cx))) {
        d <- dim(cx) <- dim(m)
        dimnames(cx) <- dn
    }
    if (missing(iN0)) 
        iN0 <- 1L + .Call(m_encodeInd, non0ind(x, cld), di = d, 
            FALSE, FALSE)
    if (asLogical) {
        cx[m] <- "|"
        if (!extends(cld, "sparseMatrix")) 
            x <- as(x, "sparseMatrix")
        if (anyFalse(x@x)) {
            if (extends(cld, "TsparseMatrix")) {
                x <- as(x, "CsparseMatrix")
                cld <- getClassDef(class(x))
            }
            F. <- is0(x@x)
            ij <- non0.i(x, cld, uniqT = FALSE)
            if (extends(cld, "symmetricMatrix")) {
                notdiag <- ij[, 1] != ij[, 2]
                ij <- rbind(ij, ij[notdiag, 2:1], deparse.level = 0)
                F. <- c(F., F.[notdiag])
            }
            iN0 <- 1L + .Call(m_encodeInd, ij, di = d, FALSE, 
                FALSE)
            cx[iN0[F.]] <- ":"
        }
    }
    else if (match.arg(align) == "fancy" && !is.integer(m)) {
        fi <- apply(m, 2, format.info)
        cols <- 1L + (0:(prod(d) - 1L))[-iN0]%/%d[1]
        pad <- ifelse(fi[3, ] == 0, fi[2, ] + as.logical(fi[2, 
            ] > 0), fi[2, ] + fi[3, ] + 4)
        if (any(doP <- pad > 0)) {
            z.p.pad <- rep.int(zero.print, length(pad))
            z.p.pad[doP] <- sprintf("%-*s", pad[doP] + 1, zero.print)
            zero.print <- z.p.pad[cols]
        }
        else zero.print <- rep.int(zero.print, length(cols))
    }
    if (!asLogical && isTRUE(uniDiag)) {
        if (any(diag(x) != 1)) 
            stop("uniDiag=TRUE, but not all diagonal entries are 1")
        D <- diag(cx)
        if (any((ir <- regexpr("1", D)) < 0)) {
            warning("uniDiag=TRUE, not all entries in diagonal coded as 1")
        }
        else {
            ir <- as.vector(ir)
            nD <- nchar(D, "bytes")
            substr(D, ir, nD) <- sprintf("I%*s", nD - ir, "")
            diag(cx) <- D
        }
    }
    cx[-iN0] <- zero.print
    cx
}


`.__T__writeMM:Matrix` <- "<environment>"

.__C__TsparseMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    j = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods")), contains = list(
    sparseMatrix = new("SClassExtension", subClass = "TsparseMatrix", 
        superClass = "sparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("TsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "TsparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), simple = TRUE, by = "sparseMatrix", 
        dataPart = FALSE, distance = 2), mMatrix = new("SClassExtension", 
        subClass = "TsparseMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), Mnumeric = new("SClassExtension", subClass = "TsparseMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), replValueSp = new("SClassExtension", subClass = "TsparseMatrix", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "TsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(Tsparse_validate, object), access = list(), className = structure("TsparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dgTMatrix = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "TsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("dgTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtTMatrix = new("SClassExtension", subClass = "dtTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("dtTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsTMatrix = new("SClassExtension", subClass = "dsTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("dsTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lgTMatrix = new("SClassExtension", subClass = "lgTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("lgTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ltTMatrix = new("SClassExtension", subClass = "ltTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("ltTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), lsTMatrix = new("SClassExtension", subClass = "lsTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("lsTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ngTMatrix = new("SClassExtension", subClass = "ngTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("ngTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ntTMatrix = new("SClassExtension", subClass = "ntTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("ntTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsTMatrix = new("SClassExtension", subClass = "nsTMatrix", 
        superClass = "TsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "TsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "TsparseMatrix", dQuote("nsTMatrix"), "TsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


.m2dgC <- function (from) 
{
    if (!is.double(from)) 
        storage.mode(from) <- "double"
    .Call(matrix_to_Csparse, from, "dgCMatrix")
}


.trDiagonal <- function (n, x = 1, uplo = "U", unitri = TRUE, kind) 
.sparseDiagonal(n, x, uplo, shape = "t", unitri = unitri, kind = kind)


`.__T__qr.qty:base` <- "<environment>"

BunchKaufman <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("BunchKaufman"), generic = "BunchKaufman", package = "Matrix", 
    group = list(), valueClass = character(0), signature = "x", 
    default = NULL, skeleton = (function (x, ...) 
    stop("invalid call in method dispatch to 'BunchKaufman' (no default method)", 
        domain = NA))(x, ...))


readMM <- function (file) 
{
    if (is.character(file)) 
        file <- if (file == "") 
            stdin()
        else file(file)
    if (!inherits(file, "connection")) 
        stop("'file' must be a character string or connection")
    if (!isOpen(file)) {
        open(file)
        on.exit(close(file))
    }
    scan1 <- function(what, ...) scan(file, nmax = 1, what = what, 
        quiet = TRUE, ...)
    if (scan1(character()) != "%%MatrixMarket") 
        stop("file is not a MatrixMarket file")
    if (!(typ <- tolower(scan1(character()))) %in% "matrix") 
        stop(gettextf("type '%s' not recognized", typ), domain = NA)
    if (!(repr <- tolower(scan1(character()))) %in% c("coordinate", 
        "array")) 
        stop(gettextf("representation '%s' not recognized", repr), 
            domain = NA)
    elt <- tolower(scan1(character()))
    if (!elt %in% c("real", "complex", "integer", "pattern")) 
        stop(gettextf("element type '%s' not recognized", elt), 
            domain = NA)
    sym <- tolower(scan1(character()))
    if (!sym %in% c("general", "symmetric", "skew-symmetric", 
        "hermitian")) 
        stop(gettextf("symmetry form '%s' not recognized", sym), 
            domain = NA)
    nr <- scan1(integer(), comment.char = "%")
    nc <- scan1(integer())
    nz <- scan1(integer())
    checkIJ <- function(els) {
        if (any(els$i < 1 | els$i > nr)) 
            stop("readMM(): row\t values 'i' are not in 1:nr", 
                call. = FALSE)
        if (any(els$j < 1 | els$j > nc)) 
            stop("readMM(): column values 'j' are not in 1:nc", 
                call. = FALSE)
    }
    if (repr == "coordinate") {
        switch(elt, real = , integer = {
            els <- scan(file, nmax = nz, quiet = TRUE, what = list(i = integer(), 
                j = integer(), x = numeric()))
            checkIJ(els)
            switch(sym, general = {
                new("dgTMatrix", Dim = c(nr, nc), i = els$i - 
                  1L, j = els$j - 1L, x = els$x)
            }, symmetric = {
                new("dsTMatrix", uplo = "L", Dim = c(nr, nc), 
                  i = els$i - 1L, j = els$j - 1L, x = els$x)
            }, `skew-symmetric` = {
                stop("symmetry form 'skew-symmetric' not yet implemented for reading")
                new("dgTMatrix", uplo = "L", Dim = c(nr, nc), 
                  i = els$i - 1L, j = els$j - 1L, x = els$x)
            }, hermitian = {
                stop("symmetry form 'hermitian' not yet implemented for reading")
            }, stop(gettextf("symmetry form '%s' is not yet implemented", 
                sym), domain = NA))
        }, pattern = {
            els <- scan(file, nmax = nz, quiet = TRUE, what = list(i = integer(), 
                j = integer()))
            checkIJ(els)
            switch(sym, general = {
                new("ngTMatrix", Dim = c(nr, nc), i = els$i - 
                  1L, j = els$j - 1L)
            }, symmetric = {
                new("nsTMatrix", uplo = "L", Dim = c(nr, nc), 
                  i = els$i - 1L, j = els$j - 1L)
            }, `skew-symmetric` = {
                stop("symmetry form 'skew-symmetric' not yet implemented for reading")
                new("ngTMatrix", uplo = "L", Dim = c(nr, nc), 
                  i = els$i - 1L, j = els$j - 1L)
            }, hermitian = {
                stop("symmetry form 'hermitian' not yet implemented for reading")
            }, stop(gettextf("symmetry form '%s' is not yet implemented", 
                sym), domain = NA))
        }, complex = {
            stop("element type 'complex' not yet implemented")
        }, stop(gettextf("'%s()' is not yet implemented for element type '%s'", 
            "readMM", elt), domain = NA))
    }
    else stop(gettextf("'%s()' is not yet implemented for  representation '%s'", 
        "readMM", repr), domain = NA)
}


qr.qy <- new("standardGeneric", .Data = function (qr, y) 
standardGeneric("qr.qy"), generic = "qr.qy", package = "base", 
    group = list(), valueClass = character(0), signature = c("qr", 
    "y"), default = new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
        if (isTRUE(attr(qr, "useLAPACK"))) 
            return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        k <- as.integer(qr$rank)
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        storage.mode(y) <- "double"
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, qy = y)$qy
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.qy"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (qr, 
        y) 
    {
        if (!is.qr(qr)) 
            stop("argument is not a QR decomposition")
        if (is.complex(qr$qr)) 
            return(.Internal(qr_qy_cmplx(qr, as.matrix(y), FALSE)))
        if (isTRUE(attr(qr, "useLAPACK"))) 
            return(.Internal(qr_qy_real(qr, as.matrix(y), FALSE)))
        n <- as.integer(nrow(qr$qr))
        if (is.na(n)) 
            stop("invalid nrow(qr$qr)")
        k <- as.integer(qr$rank)
        ny <- as.integer(NCOL(y))
        if (is.na(ny)) 
            stop("invalid NCOL(y)")
        storage.mode(y) <- "double"
        if (NROW(y) != n) 
            stop("'qr' and 'y' must have the same number of rows")
        .Fortran(.F_dqrqy, as.double(qr$qr), n, k, as.double(qr$qraux), 
            y, ny, qy = y)$qy
    }, target = new("signature", .Data = "ANY", names = "qr", 
        package = "methods"), defined = new("signature", .Data = "ANY", 
        names = "qr", package = "methods"), generic = "qr.qy"))(qr, 
        y))


`.__T__is.finite:base` <- "<environment>"

.__C__denseLU <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    perm = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods"), 
    Dim = structure("integer", package = "methods")), contains = list(
    LU = new("SClassExtension", subClass = "denseLU", superClass = "LU", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "LU")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "LU", dQuote("denseLU"), "LU", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), MatrixFactorization = new("SClassExtension", 
        subClass = "denseLU", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("LU"), "MatrixFactorization", 
                  dQuote(class(value))), domain = NA)
            value
        }, "denseLU"), simple = TRUE, by = "LU", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    .Call(LU_validate, object), access = list(), className = structure("denseLU", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.__C__dMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(Matrix = new("SClassExtension", subClass = "dMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xMatrix = new("SClassExtension", subClass = "dMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xMatrix", dQuote("dMatrix"), "xMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), mMatrix = new("SClassExtension", subClass = "dMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "mMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "mMatrix", dQuote("Matrix"), "mMatrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 2), Mnumeric = new("SClassExtension", subClass = "dMatrix", 
        superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, simple = TRUE, by = "Matrix", dataPart = FALSE, distance = 2), 
        replValueSp = new("SClassExtension", subClass = "dMatrix", 
            superClass = "replValueSp", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            {
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, simple = TRUE, by = "Matrix", dataPart = FALSE, 
            distance = 2)), virtual = TRUE, prototype = S4_object(), 
    validity = function (object) 
    .Call(dMatrix_validate, object), access = list(), className = structure("dMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(ddenseMatrix = new("SClassExtension", 
        subClass = "ddenseMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsparseMatrix = new("SClassExtension", 
        subClass = "dsparseMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), ddiMatrix = new("SClassExtension", subClass = "ddiMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddiMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgeMatrix = new("SClassExtension", subClass = "dgeMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dgeMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), dtrMatrix = new("SClassExtension", 
        subClass = "dtrMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtrMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), dtpMatrix = new("SClassExtension", 
        subClass = "dtpMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dtpMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), dsyMatrix = new("SClassExtension", 
        subClass = "dsyMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dsyMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), dspMatrix = new("SClassExtension", 
        subClass = "dspMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dspMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 2), dpoMatrix = new("SClassExtension", 
        subClass = "dpoMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dpoMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), dppMatrix = new("SClassExtension", 
        subClass = "dppMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                from <- {
                  class(from) <- "dspMatrix"
                  from
                }
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("ddenseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "dppMatrix"), simple = TRUE, by = "ddenseMatrix", 
        dataPart = FALSE, distance = 3), corMatrix = new("SClassExtension", 
        subClass = "corMatrix", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dpoMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(value, what) <- slot(from, what)
                value
            }
            {
                from <- {
                  class(from) <- "dsyMatrix"
                  from
                }
                from
            }
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dpoMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "factors")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dpoMatrix", dataPart = FALSE, 
        distance = 4), Cholesky = new("SClassExtension", subClass = "Cholesky", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dtrMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), pCholesky = new("SClassExtension", subClass = "pCholesky", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        {
            from <- {
                class(from) <- "dtpMatrix"
                from
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3), BunchKaufman = new("SClassExtension", 
        subClass = "BunchKaufman", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtrMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtrMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtrMatrix", dataPart = FALSE, 
        distance = 3), pBunchKaufman = new("SClassExtension", 
        subClass = "pBunchKaufman", superClass = "dMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        {
            from <- {
                value <- new("dtpMatrix")
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(value, what) <- slot(from, what)
                value
            }
            from
        }, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            .value <- as(from, "dtpMatrix", TRUE)
            as(.value, "dMatrix") <- value
            value <- .value
            {
                for (what in c("x", "Dim", "Dimnames", "uplo", 
                "diag")) slot(from, what) <- slot(value, what)
                from
            }
        }, simple = TRUE, by = "dtpMatrix", dataPart = FALSE, 
        distance = 3)), versionKey = <pointer: (nil)>, sealed = FALSE)


crossprod <- new("standardGeneric", .Data = function (x, y = NULL, ...) 
standardGeneric("crossprod"), generic = "crossprod", package = "base", 
    group = list(), valueClass = character(0), signature = c("x", 
    "y"), default = new("derivedDefaultMethod", .Data = function (x, 
        y = NULL, ...) 
    base::crossprod(x, y), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "crossprod"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        y = NULL, ...) 
    base::crossprod(x, y), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "crossprod"))(x, 
        y, ...))


`.__T__isTriangular:Matrix` <- "<environment>"

`.__T__rcond:base` <- "<environment>"

writeMM <- new("standardGeneric", .Data = function (obj, file, ...) 
standardGeneric("writeMM"), generic = "writeMM", package = "Matrix", 
    group = list(), valueClass = character(0), signature = c("obj", 
    "file"), default = NULL, skeleton = (function (obj, file, 
        ...) 
    stop("invalid call in method dispatch to 'writeMM' (no default method)", 
        domain = NA))(obj, file, ...))


`.__T__isDiagonal:Matrix` <- "<environment>"

isLDL <- function (x) 
{
    stopifnot(is(x, "CHMfactor"))
    as.logical(!x@type[2])
}


as.array <- new("standardGeneric", .Data = function (x, ...) 
standardGeneric("as.array"), generic = "as.array", package = "base", 
    group = list(), valueClass = character(0), signature = "x", 
    default = new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("as.array"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "as.array"), 
    skeleton = (new("derivedDefaultMethod", .Data = function (x, 
        ...) 
    UseMethod("as.array"), target = new("signature", .Data = "ANY", 
        names = "x", package = "methods"), defined = new("signature", 
        .Data = "ANY", names = "x", package = "methods"), generic = "as.array"))(x, 
        ...))


.__C__dsparseVector <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    length = structure("numeric", package = "methods"), i = structure("numeric", package = "methods")), 
    contains = list(sparseVector = new("SClassExtension", subClass = "dsparseVector", 
        superClass = "sparseVector", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("dsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), xsparseVector = new("SClassExtension", 
        subClass = "dsparseVector", superClass = "xsparseVector", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "xsparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "xsparseVector", dQuote("dsparseVector"), "xsparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), replValueSp = new("SClassExtension", subClass = "dsparseVector", 
        superClass = "replValueSp", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseVector")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseVector", dQuote("dsparseVector"), "sparseVector", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "sparseVector", dataPart = FALSE, 
        distance = 2)), virtual = FALSE, prototype = S4_object(), 
    validity = function (object) 
    {
        if (length(object@i) != length(object@x)) 
            "'i' and 'x' differ in length"
        else TRUE
    }, access = list(), className = structure("dsparseVector", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


.dxC2mat <- function (from, chkUdiag = TRUE) 
.Call(Csparse_to_matrix, from, chkUdiag, NA)


MatrixClass <- function (cl, cld = getClassDef(cl), ...Matrix = TRUE, dropVirtual = TRUE, 
    ...) 
{
    if (is.null(pkg <- cld@package)) {
        if (is.null(pkg <- packageSlot(cl))) 
            return(character())
    }
    if (identical(pkg, "Matrix") && (!...Matrix || (cl != "indMatrix" && 
        identical(1L, grep("^[dlniz]..Matrix$", cl))))) 
        cl
    else {
        r <- .selectSuperClasses(cld@contains, dropVirtual = dropVirtual, 
            namesOnly = TRUE, ...)
        if (length(r)) {
            while (!length(r1 <- Recall(r[1], ...Matrix = ...Matrix, 
                dropVirtual = dropVirtual)) && length(r) > 1) r <- r[-1]
            r1
        }
        else r
    }
}


`.__T__%&%:Matrix` <- "<environment>"

.C2nC <- function (from, isTri = is(from, "triangularMatrix")) 
.Call(Csparse_to_nz_pattern, from, isTri)


.__C__dsparseMatrix <- new("classRepresentation", slots = list(x = structure("numeric", package = "methods"), 
    Dim = structure("integer", package = "methods"), Dimnames = structure("list", package = "methods")), 
    contains = list(dMatrix = new("SClassExtension", subClass = "dsparseMatrix", 
        superClass = "dMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), sparseMatrix = new("SClassExtension", 
        subClass = structure("dsparseMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("dsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), Matrix = new("SClassExtension", subClass = "dsparseMatrix", 
        superClass = "Matrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dsparseMatrix"), simple = TRUE, by = "dMatrix", dataPart = FALSE, 
        distance = 2), mMatrix = new("SClassExtension", subClass = "dsparseMatrix", 
        superClass = "mMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                  domain = NA)
            value
        }, "dsparseMatrix"), simple = TRUE, by = "Matrix", dataPart = FALSE, 
        distance = 3), xMatrix = new("SClassExtension", subClass = "dsparseMatrix", 
        superClass = "xMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dMatrix", dQuote("dsparseMatrix"), "dMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = "dMatrix", dataPart = FALSE, distance = 2), 
        Mnumeric = new("SClassExtension", subClass = "dsparseMatrix", 
            superClass = "Mnumeric", package = "Matrix", coerce = function (from, 
                strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "dsparseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3), replValueSp = new("SClassExtension", 
            subClass = "dsparseMatrix", superClass = "replValueSp", 
            package = "Matrix", coerce = function (from, strict = TRUE) 
            from, test = function (object) 
            TRUE, replace = function (from, to, value) 
            as({
                if (!is(value, "Matrix")) 
                  stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                    "Matrix", dQuote("dMatrix"), "Matrix", dQuote(class(value))), 
                    domain = NA)
                value
            }, "dsparseMatrix"), simple = TRUE, by = "Matrix", 
            dataPart = FALSE, distance = 3)), virtual = TRUE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("dsparseMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(dgTMatrix = new("SClassExtension", 
        subClass = "dgTMatrix", superClass = "dsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dgTMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtTMatrix = new("SClassExtension", subClass = "dtTMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dtTMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsTMatrix = new("SClassExtension", subClass = "dsTMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dsTMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgCMatrix = new("SClassExtension", subClass = "dgCMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dgCMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtCMatrix = new("SClassExtension", subClass = "dtCMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dtCMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsCMatrix = new("SClassExtension", subClass = "dsCMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dsCMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dgRMatrix = new("SClassExtension", subClass = "dgRMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dgRMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dtRMatrix = new("SClassExtension", subClass = "dtRMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dtRMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), dsRMatrix = new("SClassExtension", subClass = "dsRMatrix", 
        superClass = "dsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "dsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "dsparseMatrix", dQuote("dsRMatrix"), "dsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1)), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__nCHMsuper <- new("classRepresentation", slots = list(super = structure("integer", package = "methods"), 
    pi = structure("integer", package = "methods"), px = structure("integer", package = "methods"), 
    s = structure("integer", package = "methods"), colcount = structure("integer", package = "methods"), 
    perm = structure("integer", package = "methods"), type = structure("integer", package = "methods"), 
    Dim = structure("integer", package = "methods")), contains = list(
    CHMsuper = new("SClassExtension", subClass = "nCHMsuper", 
        superClass = "CHMsuper", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CHMsuper")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMsuper", dQuote("nCHMsuper"), "CHMsuper", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), CHMfactor = new("SClassExtension", subClass = "nCHMsuper", 
        superClass = "CHMfactor", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "CHMfactor")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CHMfactor", dQuote("CHMsuper"), "CHMfactor", 
                  dQuote(class(value))), domain = NA)
            value
        }, "nCHMsuper"), simple = TRUE, by = "CHMsuper", dataPart = FALSE, 
        distance = 2), CholeskyFactorization = new("SClassExtension", 
        subClass = "nCHMsuper", superClass = "CholeskyFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "CholeskyFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CholeskyFactorization", dQuote("CHMfactor"), 
                  "CholeskyFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMsuper"), "nCHMsuper"), simple = TRUE, by = "CHMsuper", 
        dataPart = FALSE, distance = 3), MatrixFactorization = new("SClassExtension", 
        subClass = "nCHMsuper", superClass = "MatrixFactorization", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as(as({
            if (!is(value, "MatrixFactorization")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "MatrixFactorization", dQuote("CholeskyFactorization"), 
                  "MatrixFactorization", dQuote(class(value))), 
                  domain = NA)
            value
        }, "CHMfactor"), "CHMsuper"), "nCHMsuper"), simple = TRUE, 
        by = "CHMsuper", dataPart = FALSE, distance = 4)), virtual = FALSE, 
    prototype = S4_object(), validity = NULL, access = list(), 
    className = structure("nCHMsuper", package = "Matrix"), package = "Matrix", 
    subclasses = list(), versionKey = <pointer: (nil)>, sealed = FALSE)


.__C__ngCMatrix <- new("classRepresentation", slots = list(i = structure("integer", package = "methods"), 
    p = structure("integer", package = "methods"), Dim = structure("integer", package = "methods"), 
    Dimnames = structure("list", package = "methods"), factors = structure("list", package = "methods")), 
    contains = list(CsparseMatrix = new("SClassExtension", subClass = "ngCMatrix", 
        superClass = "CsparseMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "CsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "CsparseMatrix", dQuote("ngCMatrix"), "CsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nsparseMatrix = new("SClassExtension", 
        subClass = structure("ngCMatrix", package = "Matrix"), 
        superClass = structure("nsparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nsparseMatrix", dQuote("ngCMatrix"), "nsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), generalMatrix = new("SClassExtension", 
        subClass = structure("ngCMatrix", package = "Matrix"), 
        superClass = structure("generalMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "generalMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "generalMatrix", dQuote("ngCMatrix"), "generalMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nCsparseMatrix = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "nCsparseMatrix", 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        {
            if (!is(value, "nCsparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nCsparseMatrix", dQuote("ngCMatrix"), "nCsparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, simple = TRUE, by = character(0), dataPart = FALSE, 
        distance = 1), nMatrix = new("SClassExtension", subClass = structure("ngCMatrix", package = "Matrix"), 
        superClass = "nMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "nMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "nMatrix", dQuote("nsparseMatrix"), "nMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngCMatrix"), simple = TRUE, by = "nsparseMatrix", 
        dataPart = FALSE, distance = 2), sparseMatrix = new("SClassExtension", 
        subClass = structure("ngCMatrix", package = "Matrix"), 
        superClass = structure("sparseMatrix", package = "Matrix"), 
        package = "Matrix", coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "sparseMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "sparseMatrix", dQuote("nsparseMatrix"), "sparseMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngCMatrix"), simple = TRUE, by = structure("nsparseMatrix", package = "Matrix"), 
        dataPart = FALSE, distance = 2), compMatrix = new("SClassExtension", 
        subClass = structure("ngCMatrix", package = "Matrix"), 
        superClass = "compMatrix", package = "Matrix", coerce = function (from, 
            strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as({
            if (!is(value, "compMatrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "compMatrix", dQuote("generalMatrix"), "compMatrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "ngCMatrix"), simple = TRUE, by = "generalMatrix", 
        dataPart = FALSE, distance = 2), Matrix = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "Matrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ngCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 3), mMatrix = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "mMatrix", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ngCMatrix"), simple = TRUE, by = "CsparseMatrix", 
        dataPart = FALSE, distance = 4), Mnumeric = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "Mnumeric", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ngCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4), replValueSp = new("SClassExtension", 
        subClass = "ngCMatrix", superClass = "replValueSp", package = "Matrix", 
        coerce = function (from, strict = TRUE) 
        from, test = function (object) 
        TRUE, replace = function (from, to, value) 
        as(as({
            if (!is(value, "Matrix")) 
                stop(gettextf("the computation: 'as(object,\"%s\") <- value' is valid when object has class %s only if 'is(value, \"%s\")' is TRUE ('class(value)' was %s)\n", 
                  "Matrix", dQuote("sparseMatrix"), "Matrix", 
                  dQuote(class(value))), domain = NA)
            value
        }, "CsparseMatrix"), "ngCMatrix"), simple = TRUE, by = "Matrix", 
        dataPart = FALSE, distance = 4)), virtual = FALSE, prototype = S4_object(), 
    validity = NULL, access = list(), className = structure("ngCMatrix", package = "Matrix"), 
    package = "Matrix", subclasses = list(), versionKey = <pointer: (nil)>, 
    sealed = FALSE)


`.__T__Summary:base` <- "<environment>"

.nC2d <- function (from) 
.Call(nz_pattern_to_Csparse, from, 0L)




## Package Data

CAex <- Matrix::CAex		## Albers' example Matrix with "Difficult" Eigen Factorization

KNex <- Matrix::KNex		## Koenker-Ng Example Sparse Model Matrix and Response Vector

USCounties <- Matrix::USCounties		## USCounties Contiguity Matrix



## Package Info

.skeleton_package_title = "Sparse and Dense Matrix Classes and Methods"

.skeleton_package_version = "1.2-17"

.skeleton_package_depends = ""

.skeleton_package_imports = "methods,graphics,grid,stats,utils,lattice"


## Internal

.skeleton_version = 5


## EOF